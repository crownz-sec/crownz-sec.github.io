<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="笔记内容来自于Stanford CS106L的2019年秋季视频，[链接](CS 106L Fall 2020 - Guest Lecture: Template Metaprogramming - YouTube)。 下半部分主要是C++的类相关概念以及C++11之后的一些新特性，学习如何进行现代的C++编程。 Lecture 10: Classes and Constant面向对象概览在CS1">
<meta property="og:type" content="article">
<meta property="og:title" content="Stanford CS106L 笔记——下半部分">
<meta property="og:url" content="https://crownz-sec.github.io/2022/07/31/Stanford%20CS106L%202019%20Note-Second%20half/index.html">
<meta property="og:site_name" content="crownZ&#39;s Blog">
<meta property="og:description" content="笔记内容来自于Stanford CS106L的2019年秋季视频，[链接](CS 106L Fall 2020 - Guest Lecture: Template Metaprogramming - YouTube)。 下半部分主要是C++的类相关概念以及C++11之后的一些新特性，学习如何进行现代的C++编程。 Lecture 10: Classes and Constant面向对象概览在CS1">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/crownz-sec/Blog_Source@master/Stanford-CS106L/OOP-C++.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/crownz-sec/Blog_Source@master/Stanford-CS106L/swap.gif">
<meta property="article:published_time" content="2022-07-31T04:00:00.000Z">
<meta property="article:modified_time" content="2022-07-31T04:05:23.993Z">
<meta property="article:author" content="crownZ">
<meta property="article:tag" content="学习">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/crownz-sec/Blog_Source@master/Stanford-CS106L/OOP-C++.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>Stanford CS106L 笔记——下半部分</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 6.0.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        
        <li><a class="icon" aria-label="Next post" href="/2022/07/31/Stanford%20CS106L%202019%20Note-Top%20half/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://crownz-sec.github.io/2022/07/31/Stanford%20CS106L%202019%20Note-Second%20half/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://crownz-sec.github.io/2022/07/31/Stanford%20CS106L%202019%20Note-Second%20half/&text=Stanford CS106L 笔记——下半部分"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://crownz-sec.github.io/2022/07/31/Stanford%20CS106L%202019%20Note-Second%20half/&title=Stanford CS106L 笔记——下半部分"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://crownz-sec.github.io/2022/07/31/Stanford%20CS106L%202019%20Note-Second%20half/&is_video=false&description=Stanford CS106L 笔记——下半部分"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Stanford CS106L 笔记——下半部分&body=Check out this article: https://crownz-sec.github.io/2022/07/31/Stanford%20CS106L%202019%20Note-Second%20half/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://crownz-sec.github.io/2022/07/31/Stanford%20CS106L%202019%20Note-Second%20half/&title=Stanford CS106L 笔记——下半部分"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://crownz-sec.github.io/2022/07/31/Stanford%20CS106L%202019%20Note-Second%20half/&title=Stanford CS106L 笔记——下半部分"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://crownz-sec.github.io/2022/07/31/Stanford%20CS106L%202019%20Note-Second%20half/&title=Stanford CS106L 笔记——下半部分"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://crownz-sec.github.io/2022/07/31/Stanford%20CS106L%202019%20Note-Second%20half/&title=Stanford CS106L 笔记——下半部分"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://crownz-sec.github.io/2022/07/31/Stanford%20CS106L%202019%20Note-Second%20half/&name=Stanford CS106L 笔记——下半部分&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://crownz-sec.github.io/2022/07/31/Stanford%20CS106L%202019%20Note-Second%20half/&t=Stanford CS106L 笔记——下半部分"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Lecture-10-Classes-and-Constant"><span class="toc-number">1.</span> <span class="toc-text">Lecture 10: Classes and Constant</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%A6%82%E8%A7%88"><span class="toc-number">1.1.</span> <span class="toc-text">面向对象概览</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#const-%E5%8F%98%E9%87%8F"><span class="toc-number">1.2.</span> <span class="toc-text">const-变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#const-%E6%8C%87%E9%92%88"><span class="toc-number">1.3.</span> <span class="toc-text">const-指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#const-%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">1.4.</span> <span class="toc-text">const-迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#const%E5%9B%9E%E9%A1%BE"><span class="toc-number">1.5.</span> <span class="toc-text">const回顾</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lecture-11-Operators"><span class="toc-number">2.</span> <span class="toc-text">Lecture 11: Operators</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E7%9A%84%E4%B8%80%E8%88%AC%E7%BB%8F%E9%AA%8C%E6%B3%95%E5%88%99"><span class="toc-number">2.1.</span> <span class="toc-text">重载的一般经验法则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Principle-of-Least-Astonishment-POLA"><span class="toc-number">2.2.</span> <span class="toc-text">Principle of Least Astonishment(POLA)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lecture-12-Special-Member-Functions"><span class="toc-number">3.</span> <span class="toc-text">Lecture 12: Special Member Functions</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">3.0.1.</span> <span class="toc-text">构造函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#copy-operations"><span class="toc-number">3.1.</span> <span class="toc-text">copy operations</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#copy-elision%E5%92%8CRVO%EF%BC%88return-value-optimization%EF%BC%89"><span class="toc-number">3.2.</span> <span class="toc-text">copy elision和RVO（return value optimization）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lecture-13-Move-Semantics"><span class="toc-number">4.</span> <span class="toc-text">Lecture 13: Move Semantics</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#std-vector-lt-T-Allocator-gt-emplace-back"><span class="toc-number">4.1.</span> <span class="toc-text">std: :vector&lt;T,Allocator&gt;: :emplace_back</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lvalues-and-rvalues"><span class="toc-number">4.2.</span> <span class="toc-text">lvalues and rvalues</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#move-operations-c-11"><span class="toc-number">4.3.</span> <span class="toc-text">move operations(c++11)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lecture-14-Inheritance"><span class="toc-number">5.</span> <span class="toc-text">Lecture 14: Inheritance</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Namespaces"><span class="toc-number">5.1.</span> <span class="toc-text">Namespaces</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Inheritance"><span class="toc-number">5.2.</span> <span class="toc-text">Inheritance</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lecture-15-Inheritance-and-Template"><span class="toc-number">6.</span> <span class="toc-text">Lecture 15: Inheritance and Template</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Classes"><span class="toc-number">6.1.</span> <span class="toc-text">Classes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Templates-vs-Derived-Classes"><span class="toc-number">6.2.</span> <span class="toc-text">Templates vs Derived Classes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Template-Classes"><span class="toc-number">6.3.</span> <span class="toc-text">Template Classes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Concepts-and-Constraints-C-20-%E5%A4%8D%E4%B9%A0"><span class="toc-number">6.4.</span> <span class="toc-text">Concepts and Constraints(C++20)复习</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lecture-16-RAII-and-Smart-Pointers"><span class="toc-number">7.</span> <span class="toc-text">Lecture 16: RAII and Smart Pointers</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E5%BC%95"><span class="toc-number">7.1.</span> <span class="toc-text">导引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RAII"><span class="toc-number">7.2.</span> <span class="toc-text">RAII</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Smart-Pointers"><span class="toc-number">7.3.</span> <span class="toc-text">Smart Pointers</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lecture-17-Multithreading"><span class="toc-number">8.</span> <span class="toc-text">Lecture 17: Multithreading</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Further-C-reading"><span class="toc-number">9.</span> <span class="toc-text">Further C++ reading</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">10.</span> <span class="toc-text">总结</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        Stanford CS106L 笔记——下半部分
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">crownZ</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2022-07-31T04:00:00.000Z" itemprop="datePublished">2022-07-31</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fas fa-archive"></i>
        <a class="category-link" href="/categories/C/">C++</a>
    </div>


      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link-link" href="/tags/%E5%AD%A6%E4%B9%A0/" rel="tag">学习</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <p>笔记内容来自于Stanford CS106L的2019年秋季视频，[链接](<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=Ct3QF2qENGM&list=PLCgD3ws8aVdolCexlz8f3U-RROA0s5jWA">CS 106L Fall 2020 - Guest Lecture: Template Metaprogramming - YouTube</a>)。</p>
<p>下半部分主要是C++的类相关概念以及C++11之后的一些新特性，学习如何进行现代的C++编程。</p>
<h2 id="Lecture-10-Classes-and-Constant"><a href="#Lecture-10-Classes-and-Constant" class="headerlink" title="Lecture 10: Classes and Constant"></a>Lecture 10: Classes and Constant</h2><h3 id="面向对象概览"><a href="#面向对象概览" class="headerlink" title="面向对象概览"></a>面向对象概览</h3><p>在CS106B已经学过了简单的类、对象和封装，后续将对抽象，继承和多态进行更进一步的学习。C++整体的面向对象内容如下图所示，我可以根据这张图初步理清整个体系的各个主要模块。</p>
<p><img src="https://cdn.jsdelivr.net/gh/crownz-sec/Blog_Source@master/Stanford-CS106L/OOP-C++.png" alt="OOP-C++"></p>
<p><strong>为什么C/C++文件后缀有这么多的拓展？</strong></p>
<ul>
<li>头文件：.h、.hh、.hpp</li>
<li>源文件：.cc、.cpp、.cxx、.c++、.C</li>
</ul>
<p>这取决于编译器！<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/1545080/c-code-file-extension-what-is-the-difference-between-cc-and-cpp/1545085#1545085">参考</a></p>
<ul>
<li>从历史上看，使用 .C（即大写 C）</li>
<li>现在Unix多使用.cc，Unix以外多使用.cpp</li>
<li>.h 在技术上适用于C程序，因此如果混合C和 C++ 代码，请使用.hh 代替</li>
</ul>
<h3 id="const-变量"><a href="#const-变量" class="headerlink" title="const-变量"></a>const-变量</h3><p><strong>为什么不使用全局变量？</strong></p>
<ul>
<li>“全局变量可以被程序的任何部分读取或修改，因此很难记住或推理每一种可能的用途”</li>
<li>“全局变量可以由程序的任何部分获取或设置，任何有关其使用的规则都可以很容易地被破坏或遗忘”</li>
</ul>
<p><strong>使用const的好处</strong></p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((x==<span class="number">2</span> &amp;&amp; y==<span class="number">3</span>) || (x==<span class="number">1</span>))</span><br><span class="line">	    cout &lt;&lt; <span class="string">&#x27;a&#x27;</span> &lt;&lt; endl ;</span><br><span class="line">    <span class="keyword">if</span> ((y==x<span class="number">-1</span>) &amp;&amp; (x==<span class="number">-1</span> || y=<span class="number">-1</span>))</span><br><span class="line">	    cout &lt;&lt; <span class="string">&#x27;b&#x27;</span> &lt;&lt; endl ;</span><br><span class="line">    <span class="keyword">if</span> ((x==<span class="number">3</span>) &amp;&amp; (y==<span class="number">2</span>*x))</span><br><span class="line">	    cout&lt;<span class="string">&#x27;c&#x27;</span>&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在以上代码中，f函数只是为了对x和y进行一些比较，我们显然不会在该函数中对待比较变量进行修改。但有时，我们会由于疏忽导致一些代码出现错误，而自己又很难找到bug。在上面代码的第4行最右边，我们本期望写成<code>y==-1</code>，但却写成了<code>y=-1</code>，这就导致了预期之外的错误。而如果在函数参数处使用<code>const</code>，编译器就可以为我们找到bug，因为<code>const</code>使得该函数不能修改对应参数。使用<code>const</code>的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> x, <span class="keyword">const</span> <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((x==<span class="number">2</span> &amp;&amp; y==<span class="number">3</span>) || (x==<span class="number">1</span>))</span><br><span class="line">	    cout &lt;&lt; <span class="string">&#x27;a&#x27;</span> &lt;&lt; endl ;</span><br><span class="line">    <span class="keyword">if</span> ((y==x<span class="number">-1</span>) &amp;&amp; (x==<span class="number">-1</span> || y=<span class="number">-1</span>))</span><br><span class="line">	    cout &lt;&lt; <span class="string">&#x27;b&#x27;</span> &lt;&lt; endl ;</span><br><span class="line">    <span class="keyword">if</span> ((x==<span class="number">3</span>) &amp;&amp; (y==<span class="number">2</span>*x))</span><br><span class="line">	    cout&lt;<span class="string">&#x27;c&#x27;</span>&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码是一个相当基本的用例，但这真的是<code>const</code>的所有好处吗？并不是，下面通过例子学习。</p>
<p><strong>因使用const而出错的例子</strong></p>
<p>假设我们想对一个星球的人数进行统计，写出代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">int</span> <span class="title">countPeople</span><span class="params">(Planet&amp; p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Hats are the cornerstone of modern society</span></span><br><span class="line">    <span class="built_in">addLittleHat</span>(p);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// More land; oceans were wasting space</span></span><br><span class="line">	<span class="built_in">marsify</span>(p);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// Optimization: destroy planet</span></span><br><span class="line">	<span class="comment">// This makes population counting 0(1)</span></span><br><span class="line">    <span class="built_in">deathStar</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当调用countPeople时，其内部又调用了另外三个函数，这些函数会对countPeople所接受的参数p进行修改，但我们并不想修改p，所以我们会想到使用<code>const</code>。代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">int</span> <span class="title">countPeople</span><span class="params">(<span class="keyword">const</span> Planet&amp; p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Hats are the cornerstone of modern society</span></span><br><span class="line">    <span class="built_in">addLittleHat</span>(p);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// More land; oceans were wasting space</span></span><br><span class="line">	<span class="built_in">marsify</span>(p);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// Optimization: destroy planet</span></span><br><span class="line">	<span class="comment">// This makes population counting 0(1)</span></span><br><span class="line">    <span class="built_in">deathStar</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addLittleHat</span><span class="params">(Planet&amp; p)</span> </span>&#123; </span><br><span class="line">    p.<span class="built_in">add</span>(👒); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但以上代码会产生编译错误，因为<code>addLittleHat</code>等其他函数并没有对传入参数进行<code>const</code>的限制。在 <code>p</code> 上调用<code>addLittleHat</code>就像设置一个非<code>const</code>变量等于一个<code>const</code>变量，编译器不允许这么做。如果要解决这个问题，这可能就需要使得<code>addLittleHat</code>函数也用<code>const</code>修饰参数<code>p</code>，但这么又使<code>addLittleHat</code>无法在函数体中对<code>p</code>做出修改。这使得我们陷入了两难的境地。这时可能就需要使用<code>mutable</code>来解除这一限制，但<code>mutable</code>的使用也需要再权衡一番，因为随意使用<code>mutable</code>的话，等于<code>const</code>的使用也没有意义了。</p>
<p>总结起来，<code>const</code>允许我们推断变量是否会改变。代码描述如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// The value of x here</span></span><br><span class="line">    <span class="built_in">aConstMethod</span>(x) ;</span><br><span class="line">    <span class="built_in">anotherConstMethod</span>(x) ;</span><br><span class="line">    <span class="comment">// Is the same value of x here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="const-指针"><a href="#const-指针" class="headerlink" title="const-指针"></a>const-指针</h3><p>使用带有<code>const</code>的指针有点棘手，如有疑问，请从右到左阅读。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// constant pointer to a non-constant int</span></span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> p;	<span class="comment">// (*p)++; OK!</span></span><br><span class="line">				<span class="comment">// p++; NOT allowed!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// non-constant pointer to a constant int</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* p;   <span class="comment">// (*p)++; Not OK!</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span>* p;	<span class="comment">// same with above line</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// constant pointer to a constant int</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* <span class="keyword">const</span> p;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span>* <span class="keyword">const</span> p;</span><br></pre></td></tr></table></figure>

<h3 id="const-迭代器"><a href="#const-迭代器" class="headerlink" title="const-迭代器"></a>const-迭代器</h3><ul>
<li>请记住，迭代器的作用类似于指针</li>
<li><code>const vector&lt;int&gt;::iterator itr</code>的行为类似于<code>int* const itr</code></li>
<li>要使迭代器只读，请定义一个新的<code>const</code>迭代器</li>
</ul>
<p>例子1：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector v&#123;<span class="number">1</span>, <span class="number">2312</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;::iterator itr = v.<span class="built_in">begin</span>();</span><br><span class="line">++itr;		<span class="comment">// doesn&#x27;t compile</span></span><br><span class="line">*itr = <span class="number">15</span>; 	<span class="comment">// compiles </span></span><br></pre></td></tr></table></figure>

<p>例子2:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;::iterator itr = v.<span class="built_in">begin</span>();</span><br><span class="line">*itr = <span class="number">5</span>; 	<span class="comment">//0K! changing what itr points to</span></span><br><span class="line">++itr; 		<span class="comment">//BAD! can&#x27;t modify itr</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;::const_iterator itr = v.<span class="built_in">begin</span>();</span><br><span class="line">*itr = <span class="number">5</span>; 	<span class="comment">//BAD! can&#x27;t change value of itr</span></span><br><span class="line">++itr; 		<span class="comment">//0K! changing v</span></span><br><span class="line"><span class="keyword">int</span> value = *itr; <span class="comment">//0K! reading from itr</span></span><br></pre></td></tr></table></figure>

<h3 id="const回顾"><a href="#const回顾" class="headerlink" title="const回顾"></a>const回顾</h3><p>一些小的注意点：</p>
<ul>
<li>在大多数情况下，任何没有被修改的东西都应该被标记为<code>const</code></li>
<li>通过<code>const</code>引用传递优于传递值<ul>
<li>对原语（bool、int等）来说，并不正确（因为本身就是一个很小的值，传值与传引用并没有很大的开销区别）</li>
</ul>
</li>
<li>成员函数应该同时具有<code>const</code>和非<code>const</code>迭代器</li>
<li>从右到左阅读，以了解指针</li>
<li>请不要制造炸毁地球的方法</li>
</ul>
<p><code>const</code>对象：</p>
<p>通过只允许调用<code>const</code>函数并将所有公共成员视为<code>const</code>来保证对象不会改变。这有助于程序员编写安全的代码，并为编译器提供更多信息以用于优化。</p>
<p><code>const</code>函数：</p>
<p>保证该函数不会调用除<code>const</code>函数之外的任何东西，并且不会修改任何非静态（non-static）、非可变（non-mutable）成员。</p>
<p>根据所学知识，解释以下代码中每个<code>const</code>的含义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span>* <span class="keyword">const</span> <span class="title">maClassMethod</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>* <span class="keyword">const</span> &amp; param)</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure>

<p>第1个：函数返回的指针指向一个<code>const int</code>值</p>
<p>第2个：函数返回一个<code>const</code>指针</p>
<p>第3个：param指针指向一个<code>const int</code>值</p>
<p>第4个：该函数接受一个<code>const</code>指针param </p>
<p>第5个：这是一个<code>const</code>成员函数，即这个函数不能修改这个（this）实例的任何变量</p>
<p>什么时候使用这些不同用法？参考链接：<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/15999123/const-before-parameter-vs-const-after-function-name-c">const before parameter vs const after function name c++ - Stack Overflow</a></p>
<h2 id="Lecture-11-Operators"><a href="#Lecture-11-Operators" class="headerlink" title="Lecture 11: Operators"></a>Lecture 11: Operators</h2><p>主要通过一系列代码去讲运算符重载。</p>
<h3 id="重载的一般经验法则"><a href="#重载的一般经验法则" class="headerlink" title="重载的一般经验法则"></a>重载的一般经验法则</h3><ol>
<li>由于C++的语义，某些运算符必须实现为对应类的成员函数（例如[]、()、-&gt;、=）。</li>
<li>有的必须以非成员函数的方式执行（例如，&lt;&lt;，如果您正在为rhs而不是Ihs编写类）。（自己理解：lhs左参数，rhs右参数）</li>
<li>如果是一元运算符（例如 ++），则将其作为成员函数实现。</li>
<li>如果是二元的且同等对待两个操作数的运算符（例如，两个都未更改），将其实现为非成员函数（可能是友元函数）。示例：+、&lt;。</li>
<li>如果是二元的且不是同等对待两者的运算符（更改了Ihs），则实现为成员函数（允许轻松访问 Ihs 的私有成员）。示例：+=。</li>
</ol>
<p><strong>为什么要通过非成员的方式重载&lt;&lt;？</strong></p>
<p>假设我们可以通过成员的方式去重载，这样相当于我们对<code>ostream</code>添加了一个成员函数。但<code>ostream</code>是STL库的内容，一般来说，其只可使用，而无法更改。所以，我们无法通过成员的方式去重载&lt;&lt;，转而通过非成员的方式重载。</p>
<p>示例代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="keyword">const</span> Fraction&amp; f) &#123;</span><br><span class="line">    os &lt;&lt; f.num &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; f.denam;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 为什么返回值是ostream的引用？</span></span><br><span class="line"><span class="comment">// 因为这可以使得连续cout也能成功，即cout &lt;&lt; fraction1 &lt;&lt; fraction2</span></span><br><span class="line"><span class="comment">// 对于连续的cout，编译器会将其转换为：cout.operator&lt;&lt;(fraction1).operator&lt;&lt;(fraction2)</span></span><br><span class="line"><span class="comment">// 可以看到，以上编译器的代码使用了fraction1返回的结果，所以我们在上面要返回ostream的引用</span></span><br></pre></td></tr></table></figure>

<p>但不是Fraction成员函数的&lt;&lt;如何访问其私有变量呢？使用<code>friend</code>关键字，将对应函数声明为友元函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fraction</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Fraction</span>();</span><br><span class="line">	<span class="built_in">Fraction</span>(<span class="keyword">int</span> num, <span class="keyword">int</span> denom);</span><br><span class="line">	<span class="comment">// operator double const;</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">const</span> Fraction&amp; f)</span></span>; </span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">mult</span><span class="params">(<span class="keyword">const</span> Fraction&amp; f)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">decimal</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getNum</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getDenom</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> num;	<span class="comment">// the numerator</span></span><br><span class="line">	<span class="keyword">int</span> denom; <span class="comment">// the denominator</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">reduce</span><span class="params">()</span></span>; <span class="comment">// reduce the fraction to lowest terms</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">friend</span> operators&lt;&lt;(ostream&amp; os, <span class="keyword">const</span> Fraction&amp; f);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>一些关键要点</strong></p>
<ol>
<li>始终考虑是否要使用const修饰参数。在这里，我们正在修改流，而不是Fraction结构，所以，要用const修饰Fraction。</li>
<li>返回引用，以支持链式 &lt;&lt; 的调用。</li>
<li>这里我们重载了&lt;&lt;，所以我们的类作为rhs工作，但是我们不能改变Ihs（stream library）的类。</li>
<li>当你需要实现一个非成员函数，却又需要访问私有变量时，使用<code>friend</code>。</li>
</ol>
<h3 id="Principle-of-Least-Astonishment-POLA"><a href="#Principle-of-Least-Astonishment-POLA" class="headerlink" title="Principle of Least Astonishment(POLA)"></a>Principle of Least Astonishment(POLA)</h3><p>以上标题的字面翻译：最小惊奇原则。基本意思，当你正在使用实现他人需要使用的代码时，你最好通过别人不会感到惊讶的方式去实现它。</p>
<blockquote>
<p>“If a necessary feature has a high astonishment factor, it may be necessary to redesign the feature”.</p>
</blockquote>
<ul>
<li><p>设计运算符主要是为了模仿传统用法（Design operators primarily to mimic conventional usage）</p>
</li>
<li><p>对对称运算符（+，-等）使用非成员函数实现（Use nonmember functions for symmetric operators）</p>
<p>以代码举例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Fraction a &#123;<span class="number">3</span>, <span class="number">8</span>&#125;;</span><br><span class="line">Fraction b &#123;<span class="number">11</span>, <span class="number">8</span>&#125;;</span><br><span class="line"><span class="comment">// equivalent to a.operator+(0.5), compiles</span></span><br><span class="line"><span class="keyword">if</span> (a + <span class="number">1</span> == b) cout &lt;&lt; <span class="string">&quot;I &lt;3 fractions!&quot;</span>;</span><br><span class="line"><span class="comment">// equivalent to 0.5.operator+(a), does not compile </span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">1</span> + a == b) cout &lt;&lt; <span class="string">&quot;I &lt;3 fractions!&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>如果以成员函数实现+，那么只有一行判断代码可行，而第二行不可行，因为我们只给Fraction这一类实现了对应的运算符。但第二行判断代码是很常见的使用方式，我们需要支持这样的使用，所以需要通过非成员函数实现+。</p>
</li>
<li><p>始终提供一组相关运算符中的所有运算符（Always provide all out of a set of related operators）</p>
<p>举例来说，如果你实现了==运算符，那你需要把!=，&lt;等一系列逻辑比较运算符也实现了。因为如果没有实现，当用户使用其他运算符，却发现没有时，会感到惊讶。</p>
</li>
</ul>
<h2 id="Lecture-12-Special-Member-Functions"><a href="#Lecture-12-Special-Member-Functions" class="headerlink" title="Lecture 12: Special Member Functions"></a>Lecture 12: Special Member Functions</h2><p>特殊成员函数的初步理解：如果你没有在你的类中进行声明，那么编译器将会为你创建对应的成员函数。</p>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>使用初始化列表的好处：当传入参数和成员变量同名时，可以避免使用this指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为传入参数和成员变量同名，我们需要使用this指针进行区分</span></span><br><span class="line">Fraction::<span class="built_in">Fraction</span>(<span class="keyword">int</span> num, <span class="keyword">int</span> denom) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;num = num;</span><br><span class="line">    <span class="keyword">this</span>-&gt;denom = denom;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">reduce</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以使用初始化列表去避免以上情况</span></span><br><span class="line">Fraction::<span class="built_in">Fraction</span>():<span class="built_in">num</span>(num), <span class="built_in">denom</span>(denom) &#123;</span><br><span class="line">    <span class="built_in">reduce</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="copy-operations"><a href="#copy-operations" class="headerlink" title="copy operations"></a>copy operations</h3><p>特殊成员函数（通常）由编译器自动生成，其类别如下：</p>
<ul>
<li>默认构造（Default constructor）：创建没有参数的对象。</li>
<li>拷贝构造函数（Copy constructor）：对象被创建为现有对象的副本。</li>
<li>拷贝赋值（Copy assignment）：现有对象被替换为另一个现有对象的副本。</li>
<li>析构函数（Destructor）：对象在超出其作用域时被销毁。</li>
</ul>
<p> 在以下代码中，判断每一行所对应的<code>StringVector</code>对象所调用的特殊成员函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Stringvector <span class="title">function</span><span class="params">(Stringvector vec0)</span> </span>&#123; <span class="comment">// 拷贝构造函数。因为参数是传值的，所以会创建一个原对象的拷贝</span></span><br><span class="line">    StringVector vec1;			<span class="comment">// 默认构造函数</span></span><br><span class="line">    StringVector vec2&#123;<span class="string">&quot;Ito&quot;</span>, <span class="string">&quot;En&quot;</span>, <span class="string">&quot;Green&quot;</span>&#125;;<span class="comment">// 用户所定义的构造函数，并不会调用特殊成员函数。如果没有定义，会编译错误</span></span><br><span class="line">    <span class="function">StringVector <span class="title">vec3</span><span class="params">()</span></span>;		<span class="comment">// 声明了一个函数，并不会调用构造函数</span></span><br><span class="line">    <span class="function">StringVector <span class="title">vec4</span><span class="params">(vec2)</span></span>;	<span class="comment">// 拷贝构造函数</span></span><br><span class="line">    StringVector vec5&#123;&#125;;		<span class="comment">// 默认构造函数</span></span><br><span class="line">    StringVector vec6&#123;vec3 + vec4&#125;;<span class="comment">// 拷贝构造函数</span></span><br><span class="line">    StringVector vec7 = vec4;	<span class="comment">// 拷贝构造函数，因为vec7在之前并不存在，我们在创建一个新的对象</span></span><br><span class="line">    vec7 = vec2:				<span class="comment">// 拷贝赋值，因为存在的对象vec7在被vec2的复制所覆盖</span></span><br><span class="line">    <span class="keyword">return</span> vec7:				<span class="comment">// 拷贝构造函数，因为从函数中返回时，会创建一个新的vec对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>拷贝操作必须执行的任务</strong></p>
<p>拷贝构造函数：</p>
<ul>
<li><p>使用初始化列表拷贝赋值正确的成员（int、其他对象等）</p>
<p>Use initializer list to copy members where assignment does the correct thing.﻿﻿(int, other objects, etc.)</p>
</li>
<li><p>当赋值不起作用时，深拷贝所有的成员（指向堆内存的指针）</p>
<p>Deep copy all members where assignment does not work.﻿()﻿pointers to heap memory)</p>
</li>
</ul>
<p>拷贝赋值：</p>
<ul>
<li><p>清理现有对象中即将被覆盖的所有资源</p>
<p>Clean up any resources in the existing object about to be overwritten.</p>
</li>
<li><p>当赋值起作用时，使用初始化列表拷贝成员</p>
<p>Copy members using initializer list when assignment works.</p>
</li>
<li><p>当赋值不起作用，深拷贝成员</p>
<p>Deep copy members where assignment does not work.</p>
</li>
</ul>
<p><strong>一个问题</strong></p>
<p>默认的拷贝构造函数会将指针也赋值到一个新的对象，这意味着两个对象在本质上都是一个对象，修改其中一个，另一个内容也随之修改，并没创建我们所想要的内容相同，但地址不同的对象。所以，我们需要实现自己的拷贝构造函数。</p>
<p><strong>拷贝构造函数</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">StringVector::<span class="built_in">StringVector</span>(<span class="keyword">const</span> StringVector&amp; other) <span class="keyword">noexcept</span> :  </span><br><span class="line">  <span class="built_in">logicalSize</span>(other.logivalSize), <span class="built_in">allocatedSize</span>(other.allocatedSize) &#123;</span><br><span class="line">	elems = <span class="keyword">new</span> std::string[allocatedSize];</span><br><span class="line">	std::<span class="built_in">copy</span>(other.<span class="built_in">begin</span>(), other.<span class="built_in">end</span>(), <span class="built_in">begin</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// noexcept关键字的作用：</span></span><br><span class="line"><span class="comment">// 该关键字告诉编译器，函数中不会发生异常,这有利于编译器对程序做更多的优化。</span></span><br><span class="line"><span class="comment">// 如果在运行时，noexecpt函数向外抛出了异常（如果函数内部捕捉了异常并完成处理，这种情况不算抛出异常），程序会直接终止，调用std::terminate()函数，该函数内部会调用std::abort()终止程序。</span></span><br><span class="line"><span class="comment">// Reference：https://www.cnblogs.com/sword03/p/10020344.html</span></span><br></pre></td></tr></table></figure>

<p><strong>拷贝赋值</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 应该支持一下操作：</span></span><br><span class="line"><span class="comment">// StringVector v1, v2;</span></span><br><span class="line"><span class="comment">// v1 = v2;</span></span><br><span class="line"><span class="comment">// v1.operator=(v2);</span></span><br><span class="line"><span class="comment">// v1 = (v2 = v3)</span></span><br><span class="line"><span class="comment">// v1 = v1（边界条件）</span></span><br><span class="line">StringVector&amp; StringVector::<span class="keyword">operator</span>=(<span class="keyword">const</span> StringVector&amp; other) &#123;</span><br><span class="line">	<span class="comment">// copy logicalSize, copy allocatedSize, make sure array length are same</span></span><br><span class="line">    <span class="comment">// free the old vector（因为拷贝赋值是对已有对象的各种参数进行重新赋值，所以需要删除旧有的数据空间）</span></span><br><span class="line">	<span class="comment">// change elems to a new array of size allocatedSize</span></span><br><span class="line">    <span class="comment">// copy elems from other to this</span></span><br><span class="line">    <span class="comment">// 比较地址，而不是对象的具体值（*this != other），因为如果是具体值，就相当于调用对象的==操作符，</span></span><br><span class="line">    <span class="comment">// 但我们并没有实现</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;	<span class="comment">// 对`v1 = v1`这种情况的判断，出现这种情况避免赋值，直接返回自身</span></span><br><span class="line">        <span class="keyword">delete</span> [] elems;</span><br><span class="line">        allocatedSize = other.allocatedSize;</span><br><span class="line">        logicalSize = other.logicalSize;</span><br><span class="line">        elems = <span class="keyword">new</span> std::string[allocatedSize];</span><br><span class="line">        std::<span class="built_in">copy</span>(other.<span class="built_in">begin</span>(), other.<span class="built_in">end</span>(), <span class="built_in">begin</span>());</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>阻止拷贝的方法</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggedVector</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LoggedVector</span>(<span class="keyword">int</span> num, <span class="keyword">int</span> denom) ;</span><br><span class="line">    ~<span class="built_in">LoggedVector</span>();</span><br><span class="line">    <span class="comment">// other methods</span></span><br><span class="line">    <span class="comment">// 通过显式的声明，来阻止拷贝函数的调用。如果调用了，会发生编译器错误。</span></span><br><span class="line">    <span class="built_in">LoggedVector</span> (<span class="keyword">const</span> LoggedVector&amp; rhs) = <span class="keyword">delete</span>;</span><br><span class="line">    LoggedVector&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> Loggedvector: hs) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// other stuff</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>适用的情况：对于<code>ifstream</code>这种对象，我们从中读入与读出信息，并不想对其本身进行拷贝。意思是对于这类对象，只有它们的内容才是有意义的，对它们本身做拷贝并不能带来有用的信息。</p>
<p><strong>何时写自己特殊成员函数</strong></p>
<ul>
<li>当编译器生成的默认函数不起作用时<br>最常见的原因：所有权问题<br>成员是类外部资源的句柄。（例如：指针、互斥量、文件流。）</li>
<li>如果显式地定义（或删除）拷贝构造函数、拷贝赋值或析构函数，则应定义（或删除）所有这三个。<br>理由是什么？ 因为定义其中之一的事实意味着你的成员之一存在需要解决的所有权问题。而所有权问题正是我们需要自定义特殊成员函数的原因之一。</li>
</ul>
<p><strong>注意：如果默认操作有效，则不要定义你自己的自定义操作。</strong></p>
<h3 id="copy-elision和RVO（return-value-optimization）"><a href="#copy-elision和RVO（return-value-optimization）" class="headerlink" title="copy elision和RVO（return value optimization）"></a>copy elision和RVO（return value optimization）</h3><p>拷贝省略（copy elision）和返回值优化（RVO），是C++11及之后语言标准中定义的编译优化技术。中心思想：<strong>一个函数若直接返回类对象，一般会生成临时类对象变量，这需要多次调用拷贝构造函数（copy constructor），造成效率低下。这项技术让编译器对此优化，省略其中的拷贝构造环节，达到提升效率的目的。</strong></p>
<p>一个[参考链接](<a target="_blank" rel="noopener" href="https://blog.csdn.net/davidhopper/article/details/90696200">浅谈C++11标准中的复制省略（copy elision，也叫RVO返回值优化）_知行合一2018的博客-CSDN博客_c++11 rvo</a>)。</p>
<h2 id="Lecture-13-Move-Semantics"><a href="#Lecture-13-Move-Semantics" class="headerlink" title="Lecture 13: Move Semantics"></a>Lecture 13: Move Semantics</h2><h3 id="std-vector-lt-T-Allocator-gt-emplace-back"><a href="#std-vector-lt-T-Allocator-gt-emplace-back" class="headerlink" title="std: :vector&lt;T,Allocator&gt;: :emplace_back"></a>std: :vector&lt;T,Allocator&gt;: :emplace_back</h3><p>作用：当向<code>vector</code>插入元素时，可以避免额外创建对象。代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Referece link:https://en.cppreference.com/w/cpp/container/vector/emplace_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">President</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    std::string name;</span><br><span class="line">    std::string country;</span><br><span class="line">    <span class="keyword">int</span> year;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">President</span>(std::string p_name, std::string p_country, <span class="keyword">int</span> p_year)</span><br><span class="line">        : <span class="built_in">name</span>(std::<span class="built_in">move</span>(p_name)), <span class="built_in">country</span>(std::<span class="built_in">move</span>(p_country)), <span class="built_in">year</span>(p_year)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;I am being constructed.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">President</span>(President&amp;&amp; other)</span><br><span class="line">        : <span class="built_in">name</span>(std::<span class="built_in">move</span>(other.name)), <span class="built_in">country</span>(std::<span class="built_in">move</span>(other.country)), <span class="built_in">year</span>(other.year)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;I am being moved.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    President&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> President&amp; other) = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;President&gt; reElections;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\npush_back:\n&quot;</span>;</span><br><span class="line">    reElections.<span class="built_in">push_back</span>(<span class="built_in">President</span>(<span class="string">&quot;Franklin Delano Roosevelt&quot;</span>, <span class="string">&quot;the USA&quot;</span>, <span class="number">1936</span>));</span><br><span class="line">    <span class="comment">// 通常push_back的时候，我们需要先自己创建一个要插入的元素对象</span></span><br><span class="line">    <span class="comment">// 但通过使用emplace_back，我们可以避免使用这一操作，当插入时，vector会为我们创建对应的对象</span></span><br><span class="line"></span><br><span class="line">    std::vector&lt;President&gt; elections;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;emplace_back:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">auto</span>&amp; ref = elections.<span class="built_in">emplace_back</span>(<span class="string">&quot;Nelson Mandela&quot;</span>, <span class="string">&quot;South Africa&quot;</span>, <span class="number">1994</span>);</span><br><span class="line">    <span class="built_in">assert</span>(ref.year == <span class="number">1994</span> &amp;&amp; <span class="string">&quot;uses a reference to the created object (C++17)&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="lvalues-and-rvalues"><a href="#lvalues-and-rvalues" class="headerlink" title="lvalues and rvalues"></a>lvalues and rvalues</h3><p>和右值的定义。</p>
<p><strong>基本定义</strong></p>
<ul>
<li>左值（lvalues）是具有名称（身份）的表达式。<ul>
<li>可以使用地址运算符（&amp;var）查找地址</li>
</ul>
</li>
<li>右值（rvalues）是没有名称（身份）的表达式。<ul>
<li>临时值</li>
<li>使用地址运算符（&amp;var）找不到地址</li>
</ul>
</li>
</ul>
<p>直观但技术上并不正确的理解：左值可以出现在赋值的两侧，但右值通常只能出现在赋值的右侧。</p>
<p><strong>代码例子</strong></p>
<p>以下每个表达式的值类别是什么？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val = <span class="number">2</span>;					<span class="comment">// lvalue = rvalue</span></span><br><span class="line"><span class="keyword">int</span>* ptr = <span class="number">0x02248837</span>;			<span class="comment">// lvalue = rvalue</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v1&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;		<span class="comment">// v1 = &#123;1, 2, 3&#125;, lvalue = rvalue</span></span><br><span class="line"><span class="keyword">auto</span> v4 = v1 + V2;				<span class="comment">// lvalue = rvalue</span></span><br><span class="line">V1 += v4;			 			<span class="comment">// lvalue += lvalue</span></span><br><span class="line"><span class="keyword">size_t</span> size = v.<span class="built_in">size</span>();			<span class="comment">// lvalue = rvalue</span></span><br><span class="line">val = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(size); 	<span class="comment">// lvalue = rvalue (due to cast)</span></span><br><span class="line">v1 [<span class="number">1</span>] = <span class="number">4</span>*i;					<span class="comment">// lvalue = rvalue</span></span><br><span class="line">ptr = &amp;val;						<span class="comment">// lvalue = rvalue</span></span><br><span class="line">V1 [<span class="number">2</span>] = *ptr;					<span class="comment">// lvalue = lvalue</span></span><br></pre></td></tr></table></figure>

<p>左值引用使用一个<code>&amp;</code>定义与右值引用用两个<code>&amp;</code>定义，示例如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span>* ptr = <span class="number">0x02248837</span>;</span><br><span class="line">vectorsint&gt; v1&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span>&amp; ptr2 = ptr;				<span class="comment">// ptr2 is an l-value reference</span></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; v4 = v1 + v2;			<span class="comment">// v4 is an r-value reference</span></span><br><span class="line"><span class="keyword">auto</span>&amp; ptr3 = &amp;val;				<span class="comment">// ERROR: can&#x27;t bind l-val ref to r-value</span></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; val2 = val;				<span class="comment">// ErROR: can&#x27;t bind r-val ref to l-value</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span>&amp; ptr3 = ptr + <span class="number">5</span>;		<span class="comment">// OKAY: CAN bind const l-val ref to r-value (WHY?)</span></span><br><span class="line"><span class="comment">// 上一行代码意味着将一个右值存储到ptr3这个变量中</span></span><br><span class="line"><span class="comment">// 1.因为右值不能被修改，我们需要使用const修饰，所以第7行代码出错</span></span><br><span class="line"><span class="comment">// 2.又因为左值跟右值不是一类东西，所以第8行代码出错，如果这么做了，等于把左值变成一个没有身份临时变量</span></span><br><span class="line"><span class="comment">//   但左值是有身份的，可能还在其他地方使用了，所以这么做不对</span></span><br></pre></td></tr></table></figure>

<p><strong>一个C++的编译错误</strong></p>
<p>在写代码时，可能会碰到错误：<code>&quot;Invalid non-const ref of type X&amp; from r-value of type X&quot;</code>。示例代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nocos_Lref</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; v)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">const_Lref</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; v)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nocos_Rref</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp;&amp; v)</span> </span>;</span><br><span class="line"><span class="comment">// BTW: no one uses const Rref</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v1 = v2 + v3;			<span class="comment">// v1 is l-value</span></span><br><span class="line"><span class="built_in">nocos_Lref</span>(v1); 					<span class="comment">// OKAY: l-val reference binds to l-val</span></span><br><span class="line"><span class="built_in">nocos_Rref</span>(v1);						<span class="comment">// ERROR: r-val reference can&#x27;t bind to l-val</span></span><br><span class="line"><span class="built_in">nocos_Lref</span>(v2 + v3);				<span class="comment">// ERROR: l-val reference can&#x27;t bind to r-val</span></span><br><span class="line"><span class="built_in">const_Lref</span>(v2 + v3); 				<span class="comment">// OKAY: const l-val reference binds to r-val</span></span><br><span class="line"><span class="built_in">nocos_Rref</span>(v2 + v3);				<span class="comment">// OKAY: r-val reference binds to r-val</span></span><br></pre></td></tr></table></figure>

<p>这里的主要错误就是变量的左右值绑定错误，左值和右值引用必须严格对应左值和右值，否则就会发生错误。而另外一种解决方法是将函数的左值引用参数用<code>const</code>修饰，以确保函数不会修改右值（因为右值无法通过地址运算符找到地址，一般不能出现在赋值的左侧）。</p>
<p>这里其实也回答了自己之前在CS106B学习递归时候所碰到一个问题，自己有时会将<code>v2+v3</code>这种右值传入递归函数，以避免声明一个变量，方便书写，但这样就会碰到以上类型的报错。自己在写的过程中，根据编译错误提示，发现用<code>const</code>修饰对应参数，就可以避免这个问题，但我本质并不知道为什么要这样。根据这里的学习，问题就可以得到解答。</p>
<h3 id="move-operations-c-11"><a href="#move-operations-c-11" class="headerlink" title="move operations(c++11)"></a>move operations(c++11)</h3><p>move semantics的基本想法：如果一个变量是临时变量，其马上就要消失，那我们可以“偷取”其资源。我们可以“偷取”右值的资源而不可以“偷取”左值的资源，因为右值本质是一个临时变量，马上就会消失，而左值是有身份的，在代码运行时会一直存在。如果我们投取了左值的资源，那原有左值对应的资源是什么呢？所以，这样的操作不被允许。</p>
<p>为什么右值是move semantics的关键？</p>
<ul>
<li>作为左值的对象不是一次性的，因此您可以从中复制，但绝对不能从中移动。</li>
<li>作为右值的对象是一次性的，因此您可以复制或从中移动。</li>
</ul>
<p>关键见解：如果一个对象可能被重用，你就不能窃取它的资源。（If an object might potentially be reused, you cannot steal its resources.）</p>
<p><strong>两个新特殊成员函数：</strong></p>
<ul>
<li>Move Instructor (create new from existing r-value)</li>
<li>Move assignment (overwrite existing from existing r-value)</li>
</ul>
<p>特殊成员函数的函数签名对比：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">StringVector</span>();												<span class="comment">// 构造函数</span></span><br><span class="line"><span class="built_in">StringVector</span>(<span class="keyword">const</span> StringVector&amp; other) <span class="keyword">noexcept</span>;			<span class="comment">// 拷贝构造函数</span></span><br><span class="line">StringVector&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> StringVector&amp; rhs) <span class="keyword">noexcept</span>;	<span class="comment">// 拷贝赋值</span></span><br><span class="line">~<span class="built_in">StringVector</span>();											<span class="comment">// 析构函数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">StringVector</span>(StringVector&amp;&amp; other) <span class="keyword">noexcept</span>;				<span class="comment">// 移动构造函数</span></span><br><span class="line">StringVector&amp; <span class="keyword">operator</span>=(StrinqVector&amp;&amp; rhs) <span class="keyword">noexcept</span>;		<span class="comment">// 移动赋值</span></span><br></pre></td></tr></table></figure>

<p><strong>移动构造函数与移动赋值</strong></p>
<p>移动构造函数的要点：</p>
<ul>
<li>将其他对象的内容传送到本对象（Transfer the contents of other to this.）<ul>
<li>尽可能移动而不是复制！（Move instead of copy whenever possible !）</li>
</ul>
</li>
<li>让其他对象处于未确定但有效的状态（Leave other in an undetermined but valid state.）<ul>
<li>强烈推荐：将其设置为class的默认值（Highly recommended: set it to the default value of class）</li>
</ul>
</li>
</ul>
<p>一个代码例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Axess</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Axess</span> ()</span><br><span class="line">    <span class="comment">// other special member functions</span></span><br><span class="line">    <span class="comment">// 移动构造函数</span></span><br><span class="line">    <span class="built_in">Axess</span>(Axess&amp;&amp; other) : <span class="built_in">students</span>(other.students) &#123; &#125;</span><br><span class="line">    <span class="comment">// 移动赋值</span></span><br><span class="line">    Axess&amp; <span class="keyword">operator</span>=(Axess&amp;&amp; rhs) &#123;</span><br><span class="line">    	students = rhs.students;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	vector&lt;Student&gt; sudents;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>虽然以上代码是用移动构造函数和移动赋值的对应函数签名写的，其将<code>rhs</code>绑定到右值，但在对应的函数作用域中其还是一个左值（因为能通过取地址符找到地址，其有姓名和身份）。代码<code>students = rhs.students;</code>仍然会进行拷贝操作。因而，我们需要将左值变为右值，相应的函数为<code>std::move</code>。对以上代码做修改如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Axess</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Axess</span> ()</span><br><span class="line">    <span class="comment">// other special member functions</span></span><br><span class="line">    <span class="comment">// 移动构造函数</span></span><br><span class="line">    <span class="built_in">Axess</span>(Axess&amp;&amp; other) : <span class="built_in">students</span>(std::<span class="built_in">move</span>(other.students)) &#123; &#125;</span><br><span class="line">    <span class="comment">// 移动赋值</span></span><br><span class="line">    Axess&amp; <span class="keyword">operator</span>=(Axess&amp;&amp; rhs) &#123;</span><br><span class="line">    	students = std::<span class="built_in">move</span>(rhs.students);</span><br><span class="line">        <span class="comment">// Note: move by itself does not actually move anything!</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	vector&lt;Student&gt; sudents;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>std::move</strong></p>
<p>基本作用：<code>std::move</code>无条件地将变量转换为右值。<code>std::move</code>的关键要点：</p>
<ul>
<li>移动构造函数/赋值运算符必须执行成员移动</li>
<li>作为右值值引用的参数实际上是左值</li>
<li><code>std::move</code>无条件地将表达式转换为右值</li>
<li><code>std::move</code>本身不会移动任何东西</li>
<li>在<code>std::move</code>移动对象之后，不再使用该对象</li>
</ul>
<p><strong>写一个泛型swap函数</strong></p>
<p>基本代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">v1</span><span class="params">(<span class="string">&quot;En&quot;</span>, <span class="number">73837463</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">v2</span><span class="params">(<span class="string">&quot;Ito&quot;</span>, <span class="number">10000000</span>)</span></span>;</span><br><span class="line">    <span class="built_in">swap</span>(v1, v2);</span><br><span class="line"></span><br><span class="line">    Patient patient1&#123;<span class="string">&quot;Anna&quot;</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    Patient patient2&#123;<span class="string">&quot;Avery&quot;</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="built_in">swap</span>(patient1, patient2);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>答案代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T&amp; a, T&amp; b)</span> </span>&#123;</span><br><span class="line">	<span class="function">T <span class="title">c</span><span class="params">(std::move(a))</span></span>;		<span class="comment">// move constructor</span></span><br><span class="line">    a = std::<span class="built_in">move</span>(b);		<span class="comment">// move assignment</span></span><br><span class="line">    b = std::<span class="built_in">move</span>(c);		<span class="comment">// move assignment</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>代码的模拟运行过程如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/crownz-sec/Blog_Source@master/Stanford-CS106L/swap.gif" alt="swap"></p>
<p>图中的<code>c</code>是我们声明的临时变量。以上模拟过程很明显地体现出了move semantics的本质——被<code>move</code>标记的对象（右值）的资源将会被“偷取”，以避免以往创建多个对象的过程，降低开销。</p>
<p><strong>引入移动构造函数和移动赋值之后的基本规则</strong></p>
<ul>
<li>如果你在显式定义（或删除）复制构造函数、复制赋值、移动构造函数、移动赋值或析构函数中某几个，则应定义（或删除）所有五个特殊成员函数。</li>
<li>你定义特殊成员函数其中之一的事实意味着你的类成员之一存在需要解决的所有权问题。</li>
</ul>
<h2 id="Lecture-14-Inheritance"><a href="#Lecture-14-Inheritance" class="headerlink" title="Lecture 14: Inheritance"></a>Lecture 14: Inheritance</h2><h3 id="Namespaces"><a href="#Namespaces" class="headerlink" title="Namespaces"></a>Namespaces</h3><p>因为标准库使用通用名称，例如string，max，count等，这使得库的名字很容易发生冲突。大部分现代语言使用namespaces去解决这一问题。</p>
<p>Python例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Generate a random number in Python</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(random.random())		<span class="comment"># 函数前面需要加上库名</span></span><br></pre></td></tr></table></figure>

<p>C++例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Count how many times value appears in C++</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::<span class="built_in">count</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>一个更加全面的C++代码例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//using namespace std;</span></span><br><span class="line"><span class="keyword">using</span> std::vector; </span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Lecture &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">count</span> <span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ctr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : v) &#123; </span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">                ++ctr;  </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ctr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> i : v) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">            ++count;  </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;manual count: &quot;</span> &lt;&lt; count &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;lecture count: &quot;</span> &lt;&lt; Lecture::<span class="built_in">count</span>(v) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;algorithm count: &quot;</span> &lt;&lt; std::<span class="built_in">count</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">1</span>) &lt;&lt; endl;              </span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码提示我们最好不要在文件开头使用<code>using namespace std</code>，以避免作用名字冲突的问题。为了兼顾代码的可靠性和易编写性，可以在头文件开头只引入我们所需要的命名空间。但值得注意的是，如果有多个相同的名字，即便在开头引入了对应的命名空间，在实际使用时，也必须加上对应的作用域声明，否则，还是会发生命名空间冲突。</p>
<p><strong>Scope Resolution</strong></p>
<p>为什么我们需要在我们所有的类成员函数前面写<code>ClassName::</code>？</p>
<p>这是为了让便编译器知道我们在为哪个类定义函数！</p>
<h3 id="Inheritance"><a href="#Inheritance" class="headerlink" title="Inheritance"></a>Inheritance</h3><p>动机：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span> <span class="params">(ifstream &amp;stream, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// do some stuff</span></span><br><span class="line">    stream &lt;&lt; i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span> <span class="params">(istringstream &amp;stream, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// do some stuff</span></span><br><span class="line">    stream &lt;&lt; i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上两个函数所做事情都非常相同，那么我们能不能少写一点代码？</p>
<p>尝试1：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> StreamType&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span> <span class="params">(StreamType&amp; stream, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// do some stuff</span></span><br><span class="line">    stream &lt;&lt; i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码可以工作，因为模板使用<strong>隐式接口</strong>的概念。请注意，没有需要哪些运算符/函数的列表。</p>
<p>如果存在隐式接口，则必须有<strong>显式接口</strong>。通常只称为<strong>接口</strong>，这是最简单的继承形式。</p>
<p> <strong>Java与C++的代码对比</strong></p>
<p>Java代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Drink</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">make</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tea</span> <span class="keyword">implements</span> <span class="title">Drink</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">make</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// implementation</span></span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C++代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Drink</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">make</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tea</span>:</span> <span class="keyword">public</span> Drink &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">make</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// implementation</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>从以上代码，我们知道C++中没有interface关键字。在C++中，一个类作为一个接口，其必须只包含<strong>纯虚函数</strong>。 为了实现一个个接口，一个类必须定义所有这些虚函数。而如果我们确实想在我们的类中定义一些函数时，可以通过<strong>虚函数</strong>达到这一目的。</p>
<p>尝试2：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span> <span class="params">(istream &amp;stream, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// do some stuff </span></span><br><span class="line">    stream &lt;&lt; i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只要istream实现了print（作为非虚函数），并且所有类型的流都继承自istream，那么其它流都可以使用这个print函数。此时，我们只需要写一个函数。</p>
<p>备注：没有“虚拟”成员——相反，如果一个成员与继承的成员同名，子类将隐藏父类的成员。代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line">	<span class="keyword">double</span> a: <span class="comment">// Hides A::a</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>最后是struct跟class的对比。</p>
<p>另外一点需要注意的是， C++中的struct其实几乎等同于类，只是class的成员变量默认是private，struct的成员变量默认是public。<a href="%5B%E4%B8%BA%E4%BB%80%E4%B9%88struct%E9%BB%98%E8%AE%A4%E6%98%AFpublic,%E8%80%8Cclass%E9%BB%98%E8%AE%A4%E6%98%AFprivate?_%E6%98%8E%E6%9C%88%E6%B8%85%E9%A3%8E-%E7%B2%BE%E8%BF%9B%E4%B8%8D%E6%AD%A2%E7%9A%84%E5%8D%9A%E5%AE%A2-CSDN%E5%8D%9A%E5%AE%A2_struct%E7%9A%84%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%8F%AA%E8%83%BD%E6%98%AFpublic%5D(https://blog.csdn.net/xiaxiaojing/article/details/79398299)">参考链接</a></p>
<h2 id="Lecture-15-Inheritance-and-Template"><a href="#Lecture-15-Inheritance-and-Template" class="headerlink" title="Lecture 15: Inheritance and Template"></a>Lecture 15: Inheritance and Template</h2><h3 id="Classes"><a href="#Classes" class="headerlink" title="Classes"></a>Classes</h3><p><strong>虚函数与纯虚函数</strong></p>
<p>如果一个类至少有一个纯虚函数，则称为抽象类。 （接口是抽象类的子集。）抽象类不能被实例化。代码例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>= <span class="number">0</span>; 		<span class="comment">// pure virtual function</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo2</span><span class="params">()</span> </span>;    		<span class="comment">// non-pure virtual function</span></span><br><span class="line"> 	<span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>= &#123; <span class="keyword">return</span> <span class="number">42</span>; &#125;;	<span class="comment">// regular function</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>类中的纯虚函数被所继承的类实现。非纯虚函数是指，我在当前类实现了一个通用的解决方案，如果我的派生类想要不同的解决方案时，它们可以进行重写非纯虚函数。值得注意的是，正常的函数也可以被重写，但这并不道德。<a target="_blank" rel="noopener" href="https://isocpp.org/wiki/faq/strange-inheritance#redefining-nonvirtuals">参考</a></p>
<p><strong>与继承相关的一些定义</strong></p>
<p>基类（Base，又名超类（superclass）或父类（parent））：被继承的类</p>
<p>派生类（Derived，又名子类（subclass，child））：从基类继承的类</p>
<p><strong>构造函数</strong></p>
<p>子类总是调用基类的构造函数。如果未指定，则调用基类的默认构造函数。</p>
<p><strong>析构函数</strong></p>
<p>如果你打算使你的类可继承（即，如果您的类具有任何虚函数），请将您的析构函数设为虚函数！语法：<code>virtual ~Base () &#123;&#125;</code>。否则几乎肯定会有内存泄漏。</p>
<p><strong>备注：析构函数是否是虚拟的很好地表明了一个类是否打算被继承。</strong></p>
<p>非虚拟析构函数的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">	~<span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line">	~<span class="built_in">Derived</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Base *b = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line"><span class="keyword">delete</span> b;					<span class="comment">// Never calls the destructor for Derived!</span></span><br></pre></td></tr></table></figure>

<p><strong>访问说明符</strong></p>
<ul>
<li><code>private</code>：只能被这个类访问</li>
<li><code>protected</code>：只能由此类或派生类访问</li>
<li><code>public</code>：任何人都可以访问</li>
</ul>
<p>一个代码示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Drink</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Drink</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Drink</span>(std::string flavor) : <span class="built_in">flavor</span> (flavor) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">make</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	cout &lt;&lt; <span class="string">&quot;Made tea from the Drink class!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Drink</span>() = <span class="keyword">default</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::string flavor;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tea</span>:</span> <span class="keyword">public</span> Drink &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Tea</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Tea</span>(std::string flavor) : <span class="built_in">Drink</span>(flavor) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Tea</span>() = <span class="keyword">default</span>;	<span class="comment">// final class，没有人继承它，所以我们不想让它成为虚函数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">make</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    	cout &lt;&lt; <span class="string">&#x27;Made tea from the Tea class!&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="string">	    // go get a cup</span></span><br><span class="line"><span class="string">    	// pour tea in</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string">// Tea继承Drink，并重写make函数</span></span><br></pre></td></tr></table></figure>

<h3 id="Templates-vs-Derived-Classes"><a href="#Templates-vs-Derived-Classes" class="headerlink" title="Templates vs Derived Classes"></a>Templates vs Derived Classes</h3><p>模版是静态多态性，其在编译时消耗资源，实现多态，而派生类是动态多态性，其在运行时消耗资源，实现多态。怎么决定使用哪一个？</p>
<p>使用模版的时机：</p>
<ul>
<li>运行时（runtime）效率最重要</li>
<li>无法定义公共基类</li>
</ul>
<p>使用派生类的时机：</p>
<ul>
<li>编译时（compile-time）效率是最重要的</li>
<li>想要隐藏实现</li>
<li>不希望代码膨胀（code bloat，模版会在编译时，生成不同数据类型所对应的类，这会增大代码量）</li>
</ul>
<p><strong>Casting</strong></p>
<p>Casting是指对数据类型进行转换。代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// All of these are legal:</span></span><br><span class="line"><span class="keyword">int</span> a = (<span class="keyword">int</span>)b;</span><br><span class="line"><span class="keyword">int</span> a = <span class="built_in"><span class="keyword">int</span></span>(b);</span><br><span class="line"><span class="keyword">int</span> a = <span class="keyword">static</span> cast&lt;<span class="keyword">int</span>&gt;(b);</span><br><span class="line"><span class="comment">// Using static_cast is considered best practice (although many still use old style casts)</span></span><br></pre></td></tr></table></figure>

<h3 id="Template-Classes"><a href="#Template-Classes" class="headerlink" title="Template Classes"></a>Template Classes</h3><p><strong>函数模板</strong>描述了如何构建一系列外观相似的函数，而<strong>类模板</strong>描述了如何构建一系列外观相似的类。代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里的语法表明Cotainer在没有特殊声明时，默认为std::vector&lt;T&gt;</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Container</span> =</span> std::vector&lt;T&gt;&gt;	</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Priority_Q</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Priority_Q</span>() = <span class="keyword">default</span>;</span><br><span class="line">	~<span class="built_in">Priority_Q</span>() = <span class="keyword">default</span>;</span><br><span class="line">	<span class="function">T <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T val)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="keyword">const</span> Priority_Q&amp; pq);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Container _heap;</span><br><span class="line">	<span class="keyword">size_t</span> _count&#123;<span class="number">0</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Priority_Q&lt;vector&lt;string&gt;, vector&lt;vector&lt;string&gt; &gt; &gt; queue;</span><br><span class="line">    queue.<span class="built_in">push</span>(&#123;&#125;);</span><br><span class="line">    queue.<span class="built_in">push</span>(&#123;&#125;);</span><br><span class="line">    queue.<span class="built_in">push</span>(&#123;&#125;);</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; queue &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Concepts-and-Constraints-C-20-复习"><a href="#Concepts-and-Constraints-C-20-复习" class="headerlink" title="Concepts and Constraints(C++20)复习"></a>Concepts and Constraints(C++20)复习</h3><p>C++20 引入了Constraints用于在语义层面对模板参数进行约束。而Concept 即为一系列Constraints的<strong>符号名称</strong>，方便重用Constraints的逻辑。[参考链接](<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/351320730">Constraints &amp; concepts - 知乎 (zhihu.com)</a>)</p>
<p>例子代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Collection, <span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countOccurences</span><span class="params">(<span class="keyword">const</span> Collection&lt;DataType&gt;&amp; list, DataType val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; list.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">	    <span class="keyword">if</span> (list[i] == val) ++count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码含有隐式借口，其默认传入的对象有<code>size()</code>函数和<code>[]</code>操作符。如果传入的对象没有对应的函数和操作符，程序将会报出非常难以理解的错误。因而引入了Constraints，它是对模板参数的要求，其允许我们将隐式接口转换为显式的要求。示例代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1-2行是相应的Constraints</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> It, <span class="keyword">typename</span> Type&gt;</span><br><span class="line">  <span class="keyword">requires</span> Input_Iterator&lt;It&gt; &amp;&amp; Iterator_of&lt;It&gt; &amp;&amp; Equality_comparable&lt;Value_type&lt;It&gt;, Type&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countOccurences</span><span class="params">(It begin, It end, Type val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = begin; iter != end; ++iter) &#123;</span><br><span class="line">	    <span class="keyword">if</span> (*iter == val) ++count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过使用Constraints，如果你所传入的参数不满足要求，那么你的代码将会在实际运行之前，通过Constraints那一部分的代码抛出错误。</p>
<p>Concept（概念）是一个谓词，其在编译时评估，是接口的一部分。以上代码的Concept:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> It, <span class="keyword">typename</span> Type&gt;</span><br><span class="line">  <span class="keyword">requires</span> Input_Iterator&lt;It&gt; &amp;&amp; Iterator_of&lt;It&gt; &amp;&amp; Equality_comparable&lt;Value_type&lt;It&gt;, Type&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countOccurences</span><span class="params">(It begin, It end, Type val)</span></span>;</span><br></pre></td></tr></table></figure>

<p>Concepts和Constraints可以与类模板、函数模板和非模板函数（通常是类模板的成员）一起使用。标准库有我们可以使用的Concepts，或者我们可以自己定义。</p>
<p>Concept的详细[参考链接](<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/351320730">Constraints &amp; concepts - 知乎 (zhihu.com)</a>)。</p>
<h2 id="Lecture-16-RAII-and-Smart-Pointers"><a href="#Lecture-16-RAII-and-Smart-Pointers" class="headerlink" title="Lecture 16: RAII and Smart Pointers"></a>Lecture 16: RAII and Smart Pointers</h2><h3 id="导引"><a href="#导引" class="headerlink" title="导引"></a>导引</h3><p>一个代码例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">EvaluateSalaryAndReturnName</span> <span class="params">(<span class="keyword">int</span> idNumber)</span> </span>&#123;</span><br><span class="line">    Employee* e = <span class="keyword">new</span> <span class="built_in">Employee</span>(idNumber);</span><br><span class="line">    <span class="keyword">if</span> (e.<span class="built_in">Title</span>() == <span class="string">&quot;CEO&quot;</span> || e.<span class="built_in">Salary</span>() &gt; <span class="number">100000</span>) &#123;</span><br><span class="line">		cout &lt;&lt; e.<span class="built_in">First</span>() &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">			&lt;&lt; e.<span class="built_in">Last</span>() &lt;&lt; <span class="string">&quot; is overpaid&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">auto</span> result = e.<span class="built_in">First</span>() + <span class="string">&quot; &quot;</span> + e.<span class="built_in">Last</span>();</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">delete</span> e;		<span class="comment">// what if we skip this line?</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码给出了一个常见的例子，在函数内初始化对象，然后在即将退出时，将其销毁。但实际上，函数并不是总会按照我们预期的进行，反而，函数可能在任意一个节点由于各种原因抛出异常，进而直接退出。比如，执行<code>e.Title()</code>时，如果<code>e</code>没有这一个函数，那么函数就会因为异常而退出。很明显，我们如果通过这种方式退出函数，<code>delete e</code>并没有得到执行。因为<code>new</code>关键字在堆上分配内存，即便当前函数终止远行，它们也仍然会存在于堆上，所以必须自己进行销毁。所以，以上代码可能存在内存泄漏的问题。</p>
<p><strong>更一般的考虑</strong></p>
<p>以下几种相关的C++资源都与资源的占用和归还相关。</p>
<table>
<thead>
<tr>
<th>资源</th>
<th>获取方式</th>
<th>释放方式</th>
</tr>
</thead>
<tbody><tr>
<td>Heap Memory</td>
<td>new</td>
<td>delete</td>
</tr>
<tr>
<td>Files</td>
<td>open</td>
<td>close</td>
</tr>
<tr>
<td>Locks</td>
<td>try_lock</td>
<td>unlock</td>
</tr>
<tr>
<td>Sockets</td>
<td>socket</td>
<td>close</td>
</tr>
</tbody></table>
<p><strong>Exception</strong></p>
<p>异常（Exception）是将控制和信息传递给（潜在的）异常处理程序的一种方式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="comment">// code associated with exception handler</span></span><br><span class="line">&#125; <span class="built_in"><span class="keyword">catch</span></span> ( [exception type] e ) &#123;</span><br><span class="line">	<span class="comment">// exception handler</span></span><br><span class="line">&#125; <span class="built_in"><span class="keyword">catch</span></span> ( [exception type] e ) &#123;</span><br><span class="line">	<span class="comment">// exception handler</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>强制异常安全</strong></p>
<p>函数可以有四个级别的异常安全：</p>
<ul>
<li>Nothrow exception guarantee<ul>
<li>绝对不抛出异常，例如：析构函数、交换、移动构造函数等。</li>
</ul>
</li>
<li>Strong exception guarantee<ul>
<li>回滚到函数调用之前的状态</li>
</ul>
</li>
<li>Basic exception guarantee<ul>
<li>异常后程序处于有效状态</li>
</ul>
</li>
<li>No exception guarantee<ul>
<li>资源泄漏、内存损坏等</li>
</ul>
</li>
</ul>
<p><strong>完全避免异常</strong></p>
<p>在某种情况下，其实也可以不使用异常，或者说项目的现有规模并不支持你使用异常时，需要避免使用异常。Google就是如此，它们的大部分代码都没有准备好使用异常，所以它们决定一直不使用异常，并使用其他替代方法（例如错误代码和断言）。[参考链接](<a target="_blank" rel="noopener" href="https://google.github.io/styleguide/cppguide.html#Exceptions">Google C++ Style Guide</a>)</p>
<blockquote>
<p>We forgot to do it initially, so let’s not bother getting started.</p>
</blockquote>
<h3 id="RAII"><a href="#RAII" class="headerlink" title="RAII"></a>RAII</h3><p>RAII全称为<strong>R</strong>esource <strong>A</strong>cquisition <strong>I</strong>s <strong>I</strong>nitialization，中文名叫资源获取即初始化，是一种设计理念。其可简单归纳为：所有资源都应该在<strong>构造函数</strong>中获取，所有资源都应该在<strong>析构函数</strong>中释放。另一种简称为SBRM，全称为<strong>S</strong>cope <strong>B</strong>ased <strong>M</strong>emory <strong>M</strong>anage，讲课老师喜欢的一种叫法CADRE（<strong>C</strong>onstructor <strong>A</strong>cquires, <strong>D</strong>estructor <strong>Re</strong>leases）。RAII将释放资源的代码放到析构函数，这样无论你以何种方式退出函数，资源总是会被释放。因为脱离了当前函数的作用域，对象将不复存在，因而会调用析构函数。</p>
<p><strong>采用RAII的理由</strong></p>
<ul>
<li>对象永远不应该有“半有效”状态。对象应该在创建后可用。</li>
<li>析构函数总是会被调用（即使有异常），所以资源总是会被释放的。</li>
</ul>
<p><strong>一个文件读写例子</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">input</span><span class="params">()</span></span>;</span><br><span class="line">    input.<span class="built_in">open</span>(<span class="string">&quot;hamlet.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    string line;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(input, line)) &#123;</span><br><span class="line">    	cout &lt;&lt; line &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    input.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在以上代码中，资源并未在构造函数中获取或在析构函数中释放。因为以上是先创建文件流对象，之后才使用<code>open()</code>去创建具体对象。同时，<code>close()</code>也只是在析构函数函数外部使用。这是不符合RAII的代码，但这反而是我学刚开始C++时，老师反复强调的写法，先<code>open()</code>，最后再<code>close()</code>。</p>
<p>正确写法如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printFile</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">input</span><span class="params">(<span class="string">&quot;hamlet.txt&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    string line;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(input, line)) &#123; <span class="comment">// might throw exception</span></span><br><span class="line">    	cout &lt;&lt; line &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// no close call needed!</span></span><br><span class="line">&#125;<span class="comment">// stream destructor, releases access to file</span></span><br></pre></td></tr></table></figure>

<p>在以上代码中，我们直接用构造函数创建对象，同时，文件流对象的析构函数已经写好了释放资源的代码，所以我们没有必要再使用<code>close()</code>。所以，在错误代码里面，代码整体倒也没有内存泄漏的风险，只是最后的<code>close()</code>显得很多余，且不符合RAII通过构造函数创建对象的思想。</p>
<p><strong>一个锁例子</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cleanDatabase</span><span class="params">(mutex&amp; databaseLock,</span></span></span><br><span class="line"><span class="params"><span class="function">				map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; database)</span></span>&#123;</span><br><span class="line">    databaseLock.<span class="built_in">lock</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// other threads will not modify database</span></span><br><span class="line">    <span class="comment">// modify the database</span></span><br><span class="line">    <span class="comment">// if exception thrown, mutex never unlocked!</span></span><br><span class="line">    </span><br><span class="line">    databaseLock.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码仍然是传统的思想，先加锁，读写完之后，再释放锁，这次又跟我操作系统老师讲的一样了（<del>其水平极低</del>）。正确的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cleanDatabase</span><span class="params">(mutex&amp; databaseLock,</span></span></span><br><span class="line"><span class="params"><span class="function">				map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; database)</span> </span>&#123;</span><br><span class="line">    lock_guard&lt;mutex&gt;(databaseLock);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// other threads will not modify database</span></span><br><span class="line">    <span class="comment">// modify the database</span></span><br><span class="line">    <span class="comment">// if exception thrown, that&#x27;s fine!</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// no release call needed</span></span><br><span class="line">&#125; <span class="comment">// lock always unlocked when function exits .</span></span><br></pre></td></tr></table></figure>

<p>以上代码使得函数无论以何种方式退出，锁总是会被释放。</p>
<p><strong>lock_guard的非模版实现方式</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">lock_guard</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">lock_guard</span>(mutex&amp; lock) : <span class="built_in">acquired_lock</span>(lock) &#123;</span><br><span class="line">    	acquired_lock.<span class="built_in">lock</span>()</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">lock_guard</span>() &#123;</span><br><span class="line">		acquired_lock.<span class="built_in">unlock</span>();</span><br><span class="line">	&#125; </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	mutex&amp; acquired_lock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从以上代码可以看出，为了符合RAII这种思想，我们所做的其实就是对资源的申请和释放进行封装，确保对象脱离对应作用域时，其占用的资源会被释放。同时，需要注意的是mutexes不能被复制和移动，因为代码中已经将对应的类方法设置为<code>delete</code>，一个代码例子如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mutex</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">mutex</span>(<span class="keyword">const</span> mutex&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">    mutex&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> mutex&amp; rhs) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">mutex</span>(mutex&amp;&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">    mutex&amp; <span class="keyword">operator</span>=(mutex&amp;&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，在以上实现lock_guard类时，我们是通过初试化列表来初始化lock_guard的。</p>
<p><strong>总结</strong></p>
<p>在构造函数中获取资源，并在析构函数中释放。这样，类的使用者这就不必担心资源的错误管理。</p>
<h3 id="Smart-Pointers"><a href="#Smart-Pointers" class="headerlink" title="Smart Pointers"></a>Smart Pointers</h3><p>一个CS106B的代码例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rawPtrFn</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    Node* n = <span class="keyword">new</span> Node;</span><br><span class="line">    <span class="comment">// I do some stuff with n...</span></span><br><span class="line">    <span class="comment">// if exception thrown, n never deleted!</span></span><br><span class="line">    <span class="keyword">delete</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过前面的学习，我们知道以上代码存在内存泄漏的问题。C++引入智能指针来解决这个问题。常见的智能指针如下：</p>
<ul>
<li><code>std::unique_ptr</code></li>
<li><code>std::shared_ptr </code></li>
<li><code>std::weak_ptr</code></li>
</ul>
<p>注意：<code>auto_ptr</code>在C++98引入，C++11不赞成使用，并且在C++17中被移除。所以，为了向后兼容，应避免使用这个指针。</p>
<p><strong>unique_ptr(C++11)</strong></p>
<p>通过unique_ptr改写以上代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rawPtrEn</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;Node&gt; <span class="title">n</span> <span class="params">(<span class="keyword">new</span> Node)</span></span>;</span><br><span class="line">    <span class="comment">// do some stuff with n</span></span><br><span class="line">&#125; <span class="comment">// Freed!</span></span><br></pre></td></tr></table></figure>

<p>unique_ptr不能被复制。因为如果其允许被复制的话，假设复制一次，将会有两个指针指向同一个地址，当第一个指针被销毁时，对应地址的数据已经被析构函数销毁，当第二个指针被销毁时，同样会尝试对同一个地址的数据进行销毁，但是数据在之前已经被销毁过了，所以造成了<code>double free</code>。怎么告知一个类不允许复制？通过删除复制构造函数和复制赋值即可，语法跟前面的mutex类相一致。但是，我们经常希望有多个指向同一个对象的指针。这就引入shared_ptr。</p>
<p><strong>shared_ptr(C++11)</strong></p>
<p>资源可以由任意数量的shared_ptr存储，当资源没有任何一个shared_ptr指向时，对应资源被删除。代码例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p1</span> <span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="comment">// Use p1</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::shared_ptr&lt;<span class="keyword">int</span>&gt; p2 = p1;</span><br><span class="line">        <span class="comment">// Use p1 and p2</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// Use p1</span></span><br><span class="line">&#125;<span class="comment">// Freed!</span></span><br><span class="line"><span class="comment">// 当且仅当，新的shared_ptr是通过拷贝创建时才有效</span></span><br><span class="line"><span class="comment">// 换句话说，在创建第一个shared_ptr之后，后续的只能通过拷贝创建。</span></span><br></pre></td></tr></table></figure>

<p>shared_ptr的实现方式：引用计数（Reference counting）。</p>
<ul>
<li><p>基本想法：存储一个 int，用于跟踪当前引用该数据的数字</p>
<ul>
<li><p>在拷贝构造函数/拷贝赋值中递增</p>
</li>
<li><p>在析构函数中或被拷贝覆盖时递减</p>
</li>
</ul>
</li>
<li><p>当引用计数达到 0 时释放资源</p>
</li>
</ul>
<p>注意：单个对象的shared_ptr使用仍然成立，这时的引用计数为1。代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rawPtrFn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">std::unique_ptr&lt;Node&gt; <span class="title">n</span> <span class="params">(<span class="keyword">new</span> Node)</span> </span>;</span><br><span class="line">	<span class="comment">// do some stuff with n</span></span><br><span class="line">&#125;<span class="comment">// Freed!</span></span><br></pre></td></tr></table></figure>

<p><strong>weak_ptr(C++11)</strong></p>
<p>weak_ptr与shared_ptr 类似，但其对引用计数没有贡献。经常被用于处理 shared_ptr 的循环引用，例如：循环链表。在循环链表中，指向前驱和后继的指针应该要使用weak_ptr，而非shared_ptr。对于一个包含2节点A和B的循环链表，如果使用shared_ptr，每个节点的引用计数都为2，当我们想删除B节点的资源时，我们需要将其引用计数设置为1（这样当脱离作用域时，指针才会释放资源）。为此，我需要将<code>A-&gt;next</code>销毁，销毁<code>A-&gt;next</code>就需要先将A销毁。但想销毁A时，又需要销毁<code>B-&gt;prev</code>，销毁<code>B-&gt;prev</code>又需要销毁<code>B</code>，这将陷入循环之中。</p>
<p>通过使用weak_ptr，我们仍可通过<code>A-&gt;next</code>和<code>B-&gt;prev</code>去访问对应节点，但这些指针并不影响引用计数，也就是它们只有观测权，但其本身并没有共享资源。这样，每个节点的引用计数都为1，当脱离作用域，引用计数减1，资源将得到释放。同时，weak_ptr还可以用于在延迟使用主导权的场景, 比如线程A是重要的，在A完成之后B，C线程可做可不做。这时，B和C就可以使用weak_ptr来控制。</p>
<p>参考链接：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/LLZK_/article/details/52431404">weak_ptr的作用及应用场景——shared_ptr的循环引用问题_LLZK_的博客-CSDN博客</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/DswCnblog/p/5628314.html">C++ 11 创建和使用共享 weak_ptr - 滴水瓦 - 博客园 (cnblogs.com)</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/234b818f289a">C++11智能指针（weak_ptr） - 简书 (jianshu.com)</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/26851369">c++的弱引用指针到底是为什么目的引入的？原理是咋回事 - 知乎 (zhihu.com)</a></li>
</ol>
<p><strong>unique_ptr与shared_ptr的创建</strong></p>
<p>在前面的例子中，我们的创建方法为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;Node&gt; <span class="title">n</span><span class="params">(<span class="keyword">new</span> Node)</span></span>;</span><br><span class="line"><span class="function">std::shared_ptr&lt;Node&gt; <span class="title">n</span><span class="params">(<span class="keyword">new</span> Node)</span></span>;</span><br></pre></td></tr></table></figure>

<p>但现在，我们建议使用内置的智能指针创造器，代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;Node&gt; n = std::make_unique&lt;Node&gt;();</span><br><span class="line">std::shared_ptr&lt;Node&gt; n = std::make_shared&lt;Node&gt;();</span><br></pre></td></tr></table></figure>

<p>相关的三条规则：</p>
<ul>
<li><p>函数的参数在函数之前进行评估</p>
</li>
<li><p>每个函数都是“原子的”</p>
</li>
<li><p><strong>而参数可能会以其他方式交错</strong></p>
<p>（最后一条规则现在已经在C++17中得到更改，但我们仍然更喜欢包装函数，例如make_shared具有一些性能优势等。）</p>
</li>
</ul>
<p>代码例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式1: f(expr1, expr2)</span></span><br><span class="line"><span class="built_in">f</span>( std::unique_ptr&lt;T1&gt;&#123; <span class="keyword">new</span> T1 &#125;, std::unique_ptr&lt;T2&gt;&#123; <span class="keyword">new</span> T2 &#125;);</span><br><span class="line"><span class="comment">// 方式2：f(g(expr1), h(expr2))</span></span><br><span class="line"><span class="built_in">f</span>(std::make_unique&lt;T1&gt;(), std::make_unique&lt;T2&gt;());</span><br></pre></td></tr></table></figure>

<p>基于以上规则的第三条，我们倾向于总是使用<code>std::make_unique&lt;Node&gt;()</code>这一方式。这么做的理由：new返回的指针应该属于一个资源句柄（可以调用 delete ）。如果将new返回的指针分配给普通/裸指针，则该对象可能会泄漏。</p>
<p>备注：<br>在大型程序中，裸露的 delete（即应用程序代码中的删除，而不是专门用于资源管理的代码的一部分）是一个可能的错误：如果您有 N 个 delete，您如何确定您不需要 N +1 还是 N-1？该错误可能是潜在的：它可能仅在维护期间出现。如果你有一个赤裸裸的new，你可能需要在某个地方进行赤裸的delete，所以你可能有一个错误。所以，我们应该警告任何明确的 new 和 delete 使用，同时建议用 make_unique。</p>
<p>注意：<strong>在现代C++中，我们几乎从不使用new和delete。这样可以减少很多的内存泄漏问题。</strong></p>
<h2 id="Lecture-17-Multithreading"><a href="#Lecture-17-Multithreading" class="headerlink" title="Lecture 17: Multithreading"></a>Lecture 17: Multithreading</h2><p>代码通常是顺序的，而线程（Thread）是并行执行代码的方法。</p>
<p>多线程的一些要点：</p>
<ul>
<li>如果进行多线程编程，请使用原子类型（详细参见<code>&lt;atomic&gt;</code>库）。</li>
<li><code>std:: lock guard</code> vs. <code>std:: unique_lock</code></li>
<li>常用的3种类型的“锁”/互斥锁：普通（normal）、定时（timed）、递归（recursive）（详细参见<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/thread">链接</a>）。</li>
<li>条件变量（Condition variables）允许跨线程通信（详细参见<a href="%5B%5D(https://en.cppreference.com/w/cpp/header/condition_variable)">链接</a>）。</li>
<li><code>std::async</code>是使用多线程的一种方式</li>
</ul>
<p>一个代码例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> kNumThreads = <span class="number">10</span>;</span><br><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">greet</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// make the entire function atomic</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lg</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hello there! My name is &quot;</span> &lt;&lt; id &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Greetings from my threads...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    vector&lt;std::thread&gt; threads;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span>; i &lt; kNumThreads; ++i) &#123;</span><br><span class="line">        threads.<span class="built_in">push_back</span>(std::<span class="built_in">thread</span>(greet, i));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// wait for thread1 and thread2 to finish</span></span><br><span class="line">	<span class="keyword">for</span> (std::thread&amp; t : threads) &#123;</span><br><span class="line">        t.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;All greetings done!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Further-C-reading"><a href="#Further-C-reading" class="headerlink" title="Further C++ reading"></a>Further C++ reading</h2><table>
<thead>
<tr>
<th>书名</th>
<th>作者</th>
</tr>
</thead>
<tbody><tr>
<td>Accelerated C++</td>
<td>Andrew Koenig</td>
</tr>
<tr>
<td>Effective C++</td>
<td>Scott Meyers</td>
</tr>
<tr>
<td>Effective Modern C++</td>
<td>Scott Meyers</td>
</tr>
<tr>
<td>Exceptional C++</td>
<td>Herb Sutter</td>
</tr>
<tr>
<td>Modern C++ Design</td>
<td>Andrei Alexandrescu</td>
</tr>
<tr>
<td>C++ Template Metaprogramming</td>
<td>Abrahams and Gurtovoy</td>
</tr>
<tr>
<td>C++ Concurrency in Action</td>
<td>Anthony Williams</td>
</tr>
</tbody></table>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>学完这门之后，个人感觉C++的内容确实太多了，而且最近没过几年，还会开会去确定新标准，引入新特性，这可能也算是与时俱进吧。课程是短期内看完了，而且也知道如何去看文档和学习相关的新特性了。后续就是需要多用多写，来加深对C++的理解。</p>

  </div>
</article>

    <div class="blog-post-comments">
        <div id="disqus_thread">
            <noscript>Please enable JavaScript to view the comments.</noscript>
        </div>
    </div>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Lecture-10-Classes-and-Constant"><span class="toc-number">1.</span> <span class="toc-text">Lecture 10: Classes and Constant</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%A6%82%E8%A7%88"><span class="toc-number">1.1.</span> <span class="toc-text">面向对象概览</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#const-%E5%8F%98%E9%87%8F"><span class="toc-number">1.2.</span> <span class="toc-text">const-变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#const-%E6%8C%87%E9%92%88"><span class="toc-number">1.3.</span> <span class="toc-text">const-指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#const-%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">1.4.</span> <span class="toc-text">const-迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#const%E5%9B%9E%E9%A1%BE"><span class="toc-number">1.5.</span> <span class="toc-text">const回顾</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lecture-11-Operators"><span class="toc-number">2.</span> <span class="toc-text">Lecture 11: Operators</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E7%9A%84%E4%B8%80%E8%88%AC%E7%BB%8F%E9%AA%8C%E6%B3%95%E5%88%99"><span class="toc-number">2.1.</span> <span class="toc-text">重载的一般经验法则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Principle-of-Least-Astonishment-POLA"><span class="toc-number">2.2.</span> <span class="toc-text">Principle of Least Astonishment(POLA)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lecture-12-Special-Member-Functions"><span class="toc-number">3.</span> <span class="toc-text">Lecture 12: Special Member Functions</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">3.0.1.</span> <span class="toc-text">构造函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#copy-operations"><span class="toc-number">3.1.</span> <span class="toc-text">copy operations</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#copy-elision%E5%92%8CRVO%EF%BC%88return-value-optimization%EF%BC%89"><span class="toc-number">3.2.</span> <span class="toc-text">copy elision和RVO（return value optimization）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lecture-13-Move-Semantics"><span class="toc-number">4.</span> <span class="toc-text">Lecture 13: Move Semantics</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#std-vector-lt-T-Allocator-gt-emplace-back"><span class="toc-number">4.1.</span> <span class="toc-text">std: :vector&lt;T,Allocator&gt;: :emplace_back</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lvalues-and-rvalues"><span class="toc-number">4.2.</span> <span class="toc-text">lvalues and rvalues</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#move-operations-c-11"><span class="toc-number">4.3.</span> <span class="toc-text">move operations(c++11)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lecture-14-Inheritance"><span class="toc-number">5.</span> <span class="toc-text">Lecture 14: Inheritance</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Namespaces"><span class="toc-number">5.1.</span> <span class="toc-text">Namespaces</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Inheritance"><span class="toc-number">5.2.</span> <span class="toc-text">Inheritance</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lecture-15-Inheritance-and-Template"><span class="toc-number">6.</span> <span class="toc-text">Lecture 15: Inheritance and Template</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Classes"><span class="toc-number">6.1.</span> <span class="toc-text">Classes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Templates-vs-Derived-Classes"><span class="toc-number">6.2.</span> <span class="toc-text">Templates vs Derived Classes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Template-Classes"><span class="toc-number">6.3.</span> <span class="toc-text">Template Classes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Concepts-and-Constraints-C-20-%E5%A4%8D%E4%B9%A0"><span class="toc-number">6.4.</span> <span class="toc-text">Concepts and Constraints(C++20)复习</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lecture-16-RAII-and-Smart-Pointers"><span class="toc-number">7.</span> <span class="toc-text">Lecture 16: RAII and Smart Pointers</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E5%BC%95"><span class="toc-number">7.1.</span> <span class="toc-text">导引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RAII"><span class="toc-number">7.2.</span> <span class="toc-text">RAII</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Smart-Pointers"><span class="toc-number">7.3.</span> <span class="toc-text">Smart Pointers</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lecture-17-Multithreading"><span class="toc-number">8.</span> <span class="toc-text">Lecture 17: Multithreading</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Further-C-reading"><span class="toc-number">9.</span> <span class="toc-text">Further C++ reading</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">10.</span> <span class="toc-text">总结</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://crownz-sec.github.io/2022/07/31/Stanford%20CS106L%202019%20Note-Second%20half/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://crownz-sec.github.io/2022/07/31/Stanford%20CS106L%202019%20Note-Second%20half/&text=Stanford CS106L 笔记——下半部分"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://crownz-sec.github.io/2022/07/31/Stanford%20CS106L%202019%20Note-Second%20half/&title=Stanford CS106L 笔记——下半部分"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://crownz-sec.github.io/2022/07/31/Stanford%20CS106L%202019%20Note-Second%20half/&is_video=false&description=Stanford CS106L 笔记——下半部分"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Stanford CS106L 笔记——下半部分&body=Check out this article: https://crownz-sec.github.io/2022/07/31/Stanford%20CS106L%202019%20Note-Second%20half/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://crownz-sec.github.io/2022/07/31/Stanford%20CS106L%202019%20Note-Second%20half/&title=Stanford CS106L 笔记——下半部分"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://crownz-sec.github.io/2022/07/31/Stanford%20CS106L%202019%20Note-Second%20half/&title=Stanford CS106L 笔记——下半部分"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://crownz-sec.github.io/2022/07/31/Stanford%20CS106L%202019%20Note-Second%20half/&title=Stanford CS106L 笔记——下半部分"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://crownz-sec.github.io/2022/07/31/Stanford%20CS106L%202019%20Note-Second%20half/&title=Stanford CS106L 笔记——下半部分"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://crownz-sec.github.io/2022/07/31/Stanford%20CS106L%202019%20Note-Second%20half/&name=Stanford CS106L 笔记——下半部分&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://crownz-sec.github.io/2022/07/31/Stanford%20CS106L%202019%20Note-Second%20half/&t=Stanford CS106L 笔记——下半部分"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2020-2022
    crownZ
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.2/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->
 
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script> 




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script> 
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->

    <script type="text/javascript">
        var disqus_shortname = 'crownZz';

        (function(){
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        }());
    </script>

<!-- utterances Comments -->

</body>
</html>
