<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="前言进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。 进程控制是进程管理中最基本的功能。它用于创建一个新进程，终止一个已完成的进程，或者去终止一个因出现某事件而使其无法运行下去的进程，还可负责进程运行中的状态转换。 下面是对Linux中几个重要的进程控制函数进行解析。 fork()功能f">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux中的fork()、exec()、exit()和wati()">
<meta property="og:url" content="https://crownz-sec.github.io/2020/05/04/linux_process_control/index.html">
<meta property="og:site_name" content="crownZ&#39;s Blog">
<meta property="og:description" content="前言进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。 进程控制是进程管理中最基本的功能。它用于创建一个新进程，终止一个已完成的进程，或者去终止一个因出现某事件而使其无法运行下去的进程，还可负责进程运行中的状态转换。 下面是对Linux中几个重要的进程控制函数进行解析。 fork()功能f">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/crownz-sec/Blog_Source@master/img/20200504170515.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/crownz-sec/Blog_Source@master/img/20200504170540.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/crownz-sec/Blog_Source@master/img/20200504170617.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/crownz-sec/Blog_Source@master/img/20200504170911.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/crownz-sec/Blog_Source@master/img/20200504170935.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/crownz-sec/Blog_Source@master/img/20200504171006.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/crownz-sec/Blog_Source@master/img/20200504171023.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/crownz-sec/Blog_Source@master/img/20200504171048.png">
<meta property="article:published_time" content="2020-05-04T09:00:00.000Z">
<meta property="article:modified_time" content="2020-05-27T13:47:37.563Z">
<meta property="article:author" content="crownZ">
<meta property="article:tag" content="学习">
<meta property="article:tag" content="编程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/crownz-sec/Blog_Source@master/img/20200504170515.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>Linux中的fork()、exec()、exit()和wati()</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 6.0.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="Previous post" href="/2020/05/07/prototype_chain%20_pollution/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="Next post" href="/2020/04/26/NTFS/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://crownz-sec.github.io/2020/05/04/linux_process_control/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://crownz-sec.github.io/2020/05/04/linux_process_control/&text=Linux中的fork()、exec()、exit()和wati()"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://crownz-sec.github.io/2020/05/04/linux_process_control/&title=Linux中的fork()、exec()、exit()和wati()"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://crownz-sec.github.io/2020/05/04/linux_process_control/&is_video=false&description=Linux中的fork()、exec()、exit()和wati()"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Linux中的fork()、exec()、exit()和wati()&body=Check out this article: https://crownz-sec.github.io/2020/05/04/linux_process_control/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://crownz-sec.github.io/2020/05/04/linux_process_control/&title=Linux中的fork()、exec()、exit()和wati()"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://crownz-sec.github.io/2020/05/04/linux_process_control/&title=Linux中的fork()、exec()、exit()和wati()"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://crownz-sec.github.io/2020/05/04/linux_process_control/&title=Linux中的fork()、exec()、exit()和wati()"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://crownz-sec.github.io/2020/05/04/linux_process_control/&title=Linux中的fork()、exec()、exit()和wati()"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://crownz-sec.github.io/2020/05/04/linux_process_control/&name=Linux中的fork()、exec()、exit()和wati()&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://crownz-sec.github.io/2020/05/04/linux_process_control/&t=Linux中的fork()、exec()、exit()和wati()"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#fork"><span class="toc-number">2.</span> <span class="toc-text">fork()</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD"><span class="toc-number">2.1.</span> <span class="toc-text">功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%E5%8F%8A%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">2.2.</span> <span class="toc-text">函数原型及返回值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA"><span class="toc-number">2.3.</span> <span class="toc-text">代码演示</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#exec"><span class="toc-number">3.</span> <span class="toc-text">exec()</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD-1"><span class="toc-number">3.1.</span> <span class="toc-text">功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%E5%8F%8A%E8%BF%94%E5%9B%9E%E5%80%BC-1"><span class="toc-number">3.2.</span> <span class="toc-text">函数原型及返回值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA-1"><span class="toc-number">3.3.</span> <span class="toc-text">代码演示</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#exit"><span class="toc-number">4.</span> <span class="toc-text">exit()</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD-2"><span class="toc-number">4.1.</span> <span class="toc-text">功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%E5%8F%8A%E8%BF%94%E5%9B%9E%E5%80%BC-2"><span class="toc-number">4.2.</span> <span class="toc-text">函数原型及返回值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA-2"><span class="toc-number">4.3.</span> <span class="toc-text">代码演示</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#wait"><span class="toc-number">5.</span> <span class="toc-text">wait()</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD-3"><span class="toc-number">5.1.</span> <span class="toc-text">功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%E5%8F%8A%E8%BF%94%E5%9B%9E%E5%80%BC-3"><span class="toc-number">5.2.</span> <span class="toc-text">函数原型及返回值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA-3"><span class="toc-number">5.3.</span> <span class="toc-text">代码演示</span></a></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        Linux中的fork()、exec()、exit()和wati()
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">crownZ</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2020-05-04T09:00:00.000Z" itemprop="datePublished">2020-05-04</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fas fa-archive"></i>
        <a class="category-link" href="/categories/Linux/">Linux</a>
    </div>


      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link-link" href="/tags/%E5%AD%A6%E4%B9%A0/" rel="tag">学习</a>, <a class="tag-link-link" href="/tags/%E7%BC%96%E7%A8%8B/" rel="tag">编程</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。</p>
<p>进程控制是进程管理中最基本的功能。它用于创建一个新进程，终止一个已完成的进程，或者去终止一个因出现某事件而使其无法运行下去的进程，还可负责进程运行中的状态转换。</p>
<p>下面是对Linux中几个重要的进程控制函数进行解析。</p>
<h1 id="fork"><a href="#fork" class="headerlink" title="fork()"></a>fork()</h1><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>fork函数会在运行的程序中，创建一个新进程。</p>
<p>当一个进程调用fork函数后，系统会先给新的进程分配资源，例如存储数据和代码的空间。然后把原来的进程的所有值都复制到新的新进程中，只有少数值与原来的进程的值不同，相当于克隆了一个原进程。</p>
<p>由fork 创建的新进程被称为子进程，而调用fork函数的进程称为父进程。子进程是父进程的副本，它将获得父进程数据空间、堆、栈等资源的副本。但值得注意的是，子进程持有的是上述存储空间的“副本”，这意味着父子进程间不共享这些存储空间。</p>
<h2 id="函数原型及返回值"><a href="#函数原型及返回值" class="headerlink" title="函数原型及返回值"></a>函数原型及返回值</h2><p>fork函数需要头文件unistd.h。</p>
<p>函数原型：</p>
<ul>
<li><pre><code>pid_t fork(void)
</code></pre>
</li>
</ul>
<p>pid_t是进程描述符，实质就是一个int。fork被调用一次，会返回两次数值，且可能有三种不同的值：</p>
<ol>
<li>在父进程中，fork返回新创建子进程的进程ID(通常为父进程PID+1)</li>
<li>在子进程中，fork返回0</li>
<li>如果出现错误，fork返回一个负值</li>
</ol>
<h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2><p>在Linux中新建一个fork.c文件，并键入如下代码，之后使用<code>gcc -o fork fork.c </code>编译代码，生成可运行文件fork。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; stdio.h &gt;</span> <span class="comment">//因为博客代码渲染的问题，这里头文件名两边需要加空格，实际运行时需要去除，下面的头文件都是如此</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; unistd.h &gt;</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">pid_t</span> pid;  </span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;  </span><br><span class="line">    pid = fork();   <span class="comment">//fork一个进程  </span></span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;               <span class="comment">//pid为0,  </span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;this is child process, pid is %d\n&quot;</span>,getpid());<span class="comment">//getpid返回当前进程PID  </span></span><br><span class="line">        count+=<span class="number">2</span>;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;count = %d\n&quot;</span>,count);  </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;this is father process, pid is %d\n&quot;</span>,getpid());  </span><br><span class="line">        count++;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;count = %d\n&quot;</span>,count);  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;ERROR:fork() failed!\n&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>下来在终端中运行fork，得到下图的结果。看样子像是程序中if语句的两条分支if(pid == 0)和else if(pid &gt; 0)都得到了执行。但其实不是这样，出现这种运行结果的原因是因为，在main()函数调用了fork，创建了一个新的进程，这个进程称为原来进程的子进程，而且代码完全一样。<br><img src="https://cdn.jsdelivr.net/gh/crownz-sec/Blog_Source@master/img/20200504170515.png"></p>
<p>在父进程中，fork返回创建子进程的PID，PID大于0；在子进程中，fork返回0。根据返回值的不同，有不同的执行结果。</p>
<p>而且子进程与原来的进程并发执行，谁先谁后没有规律，由操作系统调度决定。这次是父进程在前，下一次也可能是子进程在前。</p>
<h1 id="exec"><a href="#exec" class="headerlink" title="exec()"></a>exec()</h1><h2 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h2><p>exec函数是操作系统的功能，它以新的进程去代替原来的进程。</p>
<p>由于未创建新进程，进程标识符（PID）不会更改，但进程的计算机代码、数据、堆和堆栈将被新程序的代码、数据、堆和堆栈替换。</p>
<h2 id="函数原型及返回值-1"><a href="#函数原型及返回值-1" class="headerlink" title="函数原型及返回值"></a>函数原型及返回值</h2><p>exec函数需要头文件unistd.h</p>
<p>函数原型：</p>
<ul>
<li>int execl(char const *path, char const *arg0, …);</li>
<li>int execv(char const *path, char const *argv[]);</li>
<li>int execle(char const *path, char const *arg0, …, char const *envp[]);</li>
<li>int execlp(char const *file, char const *arg0, …);</li>
<li>int execve(char const *path, char const *argv[], char const *envp[]);</li>
<li>int execvp(char const *file, char const *argv[]);</li>
</ul>
<p>在上面的函数原型中，exec之后的l、v、p和e分别代表不同的操作能力，如下表：</p>
<table>
<thead>
<tr>
<th align="center">后缀</th>
<th>操作能力</th>
</tr>
</thead>
<tbody><tr>
<td align="center">l</td>
<td>接收以逗号分割的命令行参数列表，列表以NULL指针作为结束标志</td>
</tr>
<tr>
<td align="center">v</td>
<td>接收一个字符串数组的指针，数组以NULL为结束</td>
</tr>
<tr>
<td align="center">p</td>
<td>使用PATH环境变量查找要执行文件参数中命名的文件夹</td>
</tr>
<tr>
<td align="center">e</td>
<td>可通过参数传递传递环境变量</td>
</tr>
</tbody></table>
<p>exec如果成功执行，不会返回任何内容。而如果exec出错，则会返回-1，并将失败原因记录在errno中。</p>
<p>errno的几种值如下：</p>
<ol>
<li>E2BIG，参数列表超过系统限制。</li>
<li>EACCES，指定的文件具有锁或共享冲突。</li>
<li>ENOENT，找不到文件或路径名称。</li>
<li>ENOMEM，没有足够的内存可用于执行新的进程映像。</li>
</ol>
<h2 id="代码演示-1"><a href="#代码演示-1" class="headerlink" title="代码演示"></a>代码演示</h2><p>新建一个exec.c文件，并键入如下代码，之后使用gcc编译代码，生成可运行文件exec。代码主要功能是使用以上6种不同exec函数来执行“ls -a”这条命令。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; stdio.h &gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; stdlib.h &gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; unistd.h &gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; string.h &gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">  <span class="comment">//以NULL结尾的字符串数组的指针，适合包含v的exec函数参数  </span></span><br><span class="line">  <span class="keyword">char</span> *arg[] = &#123;<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-a&quot;</span>, <span class="literal">NULL</span>&#125;;  </span><br><span class="line">  <span class="comment">/** </span></span><br><span class="line"><span class="comment">   * 创建子进程并调用函数execl </span></span><br><span class="line"><span class="comment">   * execl 中希望接收以逗号分隔的参数列表，并以NULL指针为结束标志 </span></span><br><span class="line"><span class="comment">   */</span>  </span><br><span class="line">  <span class="keyword">if</span>( fork() == <span class="number">0</span> )  </span><br><span class="line">  &#123;  </span><br><span class="line">    <span class="comment">// in clild   </span></span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;1------------execl------------\n&quot;</span> );  </span><br><span class="line">    <span class="keyword">if</span>( execl( <span class="string">&quot;/bin/ls&quot;</span>, <span class="string">&quot;ls&quot;</span>,<span class="string">&quot;-a&quot;</span>, <span class="literal">NULL</span> ) == <span class="number">-1</span> )  </span><br><span class="line">    &#123;  </span><br><span class="line">      <span class="built_in">printf</span>( <span class="string">&quot;execl error &quot;</span> );  </span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="comment">/** </span></span><br><span class="line"><span class="comment">   *创建子进程并调用函数execv </span></span><br><span class="line"><span class="comment">   *execv中希望接收一个以NULL结尾的字符串数组的指针 </span></span><br><span class="line"><span class="comment">   */</span>  </span><br><span class="line">  <span class="keyword">if</span>( fork() == <span class="number">0</span> )  </span><br><span class="line">  &#123;  </span><br><span class="line">    <span class="comment">// in child   </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;2------------execv------------\n&quot;</span>);  </span><br><span class="line">    <span class="keyword">if</span>( execv( <span class="string">&quot;/bin/ls&quot;</span>,arg) &lt; <span class="number">0</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;execv error &quot;</span>);  </span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="comment">/** </span></span><br><span class="line"><span class="comment">   *创建子进程并调用 execlp </span></span><br><span class="line"><span class="comment">   *execlp中 </span></span><br><span class="line"><span class="comment">   *l希望接收以逗号分隔的参数列表，列表以NULL指针作为结束标志 </span></span><br><span class="line"><span class="comment">   *p是一个以NULL结尾的字符串数组指针，函数可以DOS的PATH变量查找子程序文件 </span></span><br><span class="line"><span class="comment">   */</span>  </span><br><span class="line">  <span class="keyword">if</span>( fork() == <span class="number">0</span> )  </span><br><span class="line">  &#123;  </span><br><span class="line">    <span class="comment">// in clhild   </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;3------------execlp------------\n&quot;</span>);  </span><br><span class="line">    <span class="keyword">if</span>( execlp( <span class="string">&quot;ls&quot;</span>, <span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-a&quot;</span>, <span class="literal">NULL</span> ) &lt; <span class="number">0</span> )  </span><br><span class="line">    &#123;  </span><br><span class="line">      <span class="built_in">printf</span>( <span class="string">&quot;execlp error &quot;</span> );  </span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="comment">/** </span></span><br><span class="line"><span class="comment">   *创建子里程并调用execvp </span></span><br><span class="line"><span class="comment">   *v 望接收到一个以NULL结尾的字符串数组的指针 </span></span><br><span class="line"><span class="comment">   *p 是一个以NULL结尾的字符串数组指针，函数可以在PATH变量查找子程序文件 </span></span><br><span class="line"><span class="comment">   */</span>  </span><br><span class="line">  <span class="keyword">if</span>( fork() == <span class="number">0</span> )  </span><br><span class="line">  &#123;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;4------------execvp------------\n&quot;</span>);  </span><br><span class="line">    <span class="keyword">if</span>( execvp( <span class="string">&quot;ls&quot;</span>, arg ) &lt; <span class="number">0</span> )  </span><br><span class="line">    &#123;  </span><br><span class="line">      <span class="built_in">printf</span>( <span class="string">&quot;execvp error &quot;</span> );  </span><br><span class="line">      <span class="built_in">exit</span>( <span class="number">1</span> );  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="comment">/** </span></span><br><span class="line"><span class="comment">   *创建子进程并调用execle </span></span><br><span class="line"><span class="comment">   *l 希望接收以逗号分隔的参数列表，列表以NULL指针作为结束标志 </span></span><br><span class="line"><span class="comment">   *e 函数传递指定参数envp，允许改变子进程的环境，无后缀e时，子进程使用当前程序的环境 </span></span><br><span class="line"><span class="comment">   */</span>  </span><br><span class="line">  <span class="keyword">if</span>( fork() == <span class="number">0</span> )  </span><br><span class="line">  &#123;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;5------------execle------------\n&quot;</span>);  </span><br><span class="line">    <span class="keyword">if</span>( execle(<span class="string">&quot;/bin/ls&quot;</span>, <span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-a&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>) == <span class="number">-1</span> )  </span><br><span class="line">    &#123;  </span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;execle error &quot;</span>);  </span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="comment">/** </span></span><br><span class="line"><span class="comment">   *创建子进程并调用execve </span></span><br><span class="line"><span class="comment">   * v 希望接收到一个以NULL结尾的字符串数组的指针 </span></span><br><span class="line"><span class="comment">   * e 函数传递指定参数envp，允许改变子进程的环境，无后缀e时，子进程使用当前程序的环境 </span></span><br><span class="line"><span class="comment">   */</span>  </span><br><span class="line">  <span class="keyword">if</span>( fork() == <span class="number">0</span> )  </span><br><span class="line">  &#123;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;6------------execve-----------\n&quot;</span>);  </span><br><span class="line">    <span class="keyword">if</span>( execve( <span class="string">&quot;/bin/ls&quot;</span>, arg, <span class="literal">NULL</span> ) == <span class="number">0</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;execve error &quot;</span>);  </span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>在终端中运行exec，得到下图的结果。可以看到顺序非常混乱，并没有按照我们程序中那样的顺序输出，这里也就体现了前面fork的特性，子进程与原来的进程并发执行，谁先谁后并没有规律，由操作系统调度决定。</p>
<p>再看所有命令的执行结果，都是“ls -a”的结果。从代码中，我们可以看到exec几种不同函数的不同使用方法，但同一条命令的执行结果都是一样的。<br><img src="https://cdn.jsdelivr.net/gh/crownz-sec/Blog_Source@master/img/20200504170540.png"></p>
<h1 id="exit"><a href="#exit" class="headerlink" title="exit()"></a>exit()</h1><h2 id="功能-2"><a href="#功能-2" class="headerlink" title="功能"></a>功能</h2><p>exit函数将会终止所调用它的进程，但在终止之前会检查文件的打开情况，把缓冲区的内容写回文件。</p>
<p>_exit函数同样是终止所调用它的进程，但它不会检查文件的打开情况，而是直接使进程停止运行，并清除进程所使用的内存空间和内核中的各种数据结构。</p>
<p>exit函数和_exit函数最终都要把控制权交给内核。</p>
<h2 id="函数原型及返回值-2"><a href="#函数原型及返回值-2" class="headerlink" title="函数原型及返回值"></a>函数原型及返回值</h2><p>exit函数需要头文件stdlib.h。</p>
<p>函数原型：</p>
<ul>
<li>void exit(int status)</li>
</ul>
<p>_exit函数需要头文件unistd.h。</p>
<p>函数原型：</p>
<ul>
<li>void _exit(int status)</li>
</ul>
<p>以上两个函数原型均无返回值。status是返回给父进程的状态值，父进程可通过wait系统调用获得。</p>
<h2 id="代码演示-2"><a href="#代码演示-2" class="headerlink" title="代码演示"></a>代码演示</h2><p>printf函数采用缓冲I/O的方式，该函数在遇到“/n”换行符时自动的从缓冲区中将记录读出。其特征就是对应每一个打开的文件，在内存中都有一片缓冲区。每次读文件时，会连续的读出若干条记录，这样在下次读文件时就可以直接从内存的缓冲区读取；同样，每次写文件的时候也仅仅是写入内存的缓冲区，等满足了一定的条件（如达到了一定数量或遇到特定字符等），再将缓冲区中的内容一次性写入文件。</p>
<p>下面的两个例子比较了这两个函数的区别。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; unistd.h &gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; stdio.h &gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; stdlib.h &gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;first line\n&quot;</span>);  <span class="comment">//遇到\n会刷新缓冲区，也就是把内容输出到屏幕上  </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;second line&quot;</span>);  </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>使用gcc编译之后，运行exit。看到两行的内容都输出了。<br><img src="https://cdn.jsdelivr.net/gh/crownz-sec/Blog_Source@master/img/20200504170617.png"></p>
<p>这个代码内容与上面一样，只是改为调用_exit()函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; unistd.h &gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; stdio.h &gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; stdlib.h &gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;first line\n&quot;</span>);  <span class="comment">//遇到\n会刷新缓冲区 </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;second line&quot;</span>);  </span><br><span class="line">    _exit(<span class="number">0</span>);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>编译后运行，发现只输出了一行，第二行并没有输出，说明_exit()函数在终止进程的时候，没有检查缓冲区，丢失了缓冲区的数据。<br><img src="https://cdn.jsdelivr.net/gh/crownz-sec/Blog_Source@master/img/20200504170911.png"></p>
<h1 id="wait"><a href="#wait" class="headerlink" title="wait()"></a>wait()</h1><h2 id="功能-3"><a href="#功能-3" class="headerlink" title="功能"></a>功能</h2><p>wait函数会使父进程（也就是调用wait()的进程）阻塞，直到一个子进程结束或者该进程接收到了一个指定的信号为止。如果该父进程没有子进程或者它的子进程已经结束，则wait()函数就会立即返回。</p>
<p>waitpid()的作用和wait()一样，但它并不一定要等待第一个终止的子进程（它可以指定需要等待终止的子进程），它还有若干选项，如可提供一个非阻塞版本的 wait()功能，也能支持作业控制。</p>
<p>实际上，wait()函数只是 waitpid()函数的一个特例，在Linux 内部实现 wait()函数时直接调用的就是waitpid()函数。</p>
<h2 id="函数原型及返回值-3"><a href="#函数原型及返回值-3" class="headerlink" title="函数原型及返回值"></a>函数原型及返回值</h2><p>wait函数和waitpid函数需要头文件sys/types.h和sys/wait.h。</p>
<p>函数原型：</p>
<ul>
<li><pre><code>pid_t wait(int *status)
</code></pre>
</li>
<li><pre><code>pid_t waitpid(pid_t pid, int *status, int options)
</code></pre>
</li>
</ul>
<p>参数：</p>
<ul>
<li>   status：子进程退出时的状态。详细如下表：</li>
</ul>
<table>
<thead>
<tr>
<th align="center">status宏名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">WIFEXITED</td>
<td>进程通过调用_exit()或exit()正常退出，该宏值非0</td>
</tr>
<tr>
<td align="center">WIFSIGNALED</td>
<td>子进程因得到的信号没有被捕捉导致退出，该宏值非0</td>
</tr>
<tr>
<td align="center">WIFSTOPPED</td>
<td>子进程没有终止但停止了，并可重新执行时，改宏值非0。仅当waitpid()调用中使用了WUNTRACED选项出现</td>
</tr>
<tr>
<td align="center">WEXITSTATUS</td>
<td>如果WIFEXITED返回非0，该宏返回由子进程调用_exit()或exit()时设置的调用参数status值</td>
</tr>
<tr>
<td align="center">WTERMSIG</td>
<td>如果WIFSIGNALED返回非0，该宏返回导致子进程退出的信号值</td>
</tr>
<tr>
<td align="center">WSTOPSIG</td>
<td>如果WIFSTOPPED返回非0，该宏返回导致子进程停止的信号值</td>
</tr>
</tbody></table>
<ul>
<li>pid：进程描述符。详细如下表：</li>
</ul>
<table>
<thead>
<tr>
<th align="center">pid取值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">pid&gt;0</td>
<td>等待进程号为pid的子进程结束</td>
</tr>
<tr>
<td align="center">pid=0</td>
<td>等待组ID等于调用组进程ID的子进程结束</td>
</tr>
<tr>
<td align="center">pid=-1</td>
<td>等待任一子进程结束，等价于调用wait()</td>
</tr>
<tr>
<td align="center">pid&lt;-1</td>
<td>等待组ID等于PID的绝对值的任一子进程结束</td>
</tr>
</tbody></table>
<ul>
<li>options：根据不同情况，来指定waitpid()的操作</li>
</ul>
<table>
<thead>
<tr>
<th align="center">options取值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">WHOHANG</td>
<td>若pid指定的子进程没结束，则waitpid()不阻塞，立即返回，返回值为0</td>
</tr>
<tr>
<td align="center">WUNTRACED</td>
<td>为实现某种操作，由pid指定的任一进程已被暂停，且其状态自暂停以来没有报告过，则返回其状态</td>
</tr>
<tr>
<td align="center">0</td>
<td>同wait()，阻塞父进程，等待子进程的退出</td>
</tr>
</tbody></table>
<h2 id="代码演示-3"><a href="#代码演示-3" class="headerlink" title="代码演示"></a>代码演示</h2><p>这个代码测试wait()函数，先用fork()新建一个子进程，然后让子进程暂停5s。接下来对原有的父进程使用wait()函数，wait()函数会使得父进程阻塞。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; unistd.h &gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; stdio.h &gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; stdlib.h &gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; sys/wait.h &gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; sys/types.h &gt;</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">pid_t</span> pc,pr;  </span><br><span class="line">    pc = fork();  <span class="comment">//创建子进程</span></span><br><span class="line">    <span class="keyword">if</span>(pc &lt; <span class="number">0</span>)&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Fork Error\n&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pc == <span class="number">0</span>)&#123;   <span class="comment">//子进程 </span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am child progress.I am going sleep!\n&quot;</span>);  </span><br><span class="line">        sleep(<span class="number">5</span>);  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am child progress.I am going exit!\n&quot;</span>);  </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">//父进程  </span></span><br><span class="line">        pr = wait(<span class="literal">NULL</span>);  </span><br><span class="line">        <span class="keyword">if</span>(pr &lt; <span class="number">0</span>)&#123;  </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Error\n&quot;</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am father progress.I get child exit code:%d\n&quot;</span>, pr); <span class="comment">//获得退出代号 </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行编译后的wait，看到父进程被阻塞，直到子进程执行完毕，返回子进程退出代号。wait()函数一个比较大的应用是可以用来写守护进程的代码，直到被守护的进程结束，守护进程继续执行自己的代码。<br><img src="https://cdn.jsdelivr.net/gh/crownz-sec/Blog_Source@master/img/20200504170935.png"></p>
<p>下面的代码用来测试waitpid()函数，仍是fork新建一个子进程，只不过同时在父进程中不断循环检测子进程的状态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; unistd.h &gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; stdio.h &gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; stdlib.h &gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; sys/wait.h &gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; sys/types.h &gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">pid_t</span> pc,pr;  </span><br><span class="line">    pc = fork();<span class="comment">//创建子进程</span></span><br><span class="line">    <span class="keyword">if</span>(pc &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Fork Error\n&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pc == <span class="number">0</span>)&#123;   <span class="comment">//子进程 </span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am child progress.I am going sleep!\n&quot;</span>);  </span><br><span class="line">        sleep(<span class="number">5</span>);  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am child progress.I am going exit!\n&quot;</span>);  </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span>&#123;    <span class="comment">//父进程</span></span><br><span class="line">        <span class="keyword">do</span>&#123;    <span class="comment">//循环检测子进程是否退出  </span></span><br><span class="line">            pr = waitpid(pc, <span class="literal">NULL</span>, WNOHANG);  <span class="comment">//设置options，使父进程不阻塞</span></span><br><span class="line">            <span class="keyword">if</span>(pr == <span class="number">0</span>)&#123;  <span class="comment">//子进程未退出，则父进程打印信息并暂停1s</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;I am father progress.The child process has not exited\n&quot;</span>);  </span><br><span class="line">            sleep(<span class="number">1</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;<span class="keyword">while</span>(pr == <span class="number">0</span>);  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pr == pc)&#123;  <span class="comment">//发现子进程退出，打印相应情况</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;I am father progress.I get child process exit code:%d\n&quot;</span>, pr);  </span><br><span class="line">    	&#125;  </span><br><span class="line">        <span class="keyword">else</span>&#123; </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Error\n&quot;</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>运行编译后的waitpid，看到父进程通过创建fork创建了一个子进程，子进程运行之后，开始暂停。在子进程暂停的这几秒间，因为设置了waitpid()函数的参数，父进程没有阻塞，反而能一直检测子进程的状态。</p>
<p>这里的waitpid()可以用来一直检测子进程状态，防止僵尸进程的出现。<br><img src="https://cdn.jsdelivr.net/gh/crownz-sec/Blog_Source@master/img/20200504171006.png"></p>
<p>下面的例子用来说明一下宏名的作用，status的宏名就是根据status的值，来返回不同的值，一些宏名和值的定义在上面的表也给过了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; stdio.h &gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; stdlib.h &gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; string.h &gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; unistd.h &gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; sys/wait.h &gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; sys/types.h &gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">out_status</span><span class="params">(<span class="keyword">int</span> status)</span></span>&#123;  <span class="comment">//根据不同status值，调用不同的宏</span></span><br><span class="line">    <span class="keyword">if</span>(WIFEXITED(status))&#123;          <span class="comment">//正常终止  </span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;normal exit: %d\n&quot;</span>, WEXITSTATUS(status));  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(WIFSIGNALED(status))&#123;   <span class="comment">//异常终止  </span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;abnormal term: %d\n&quot;</span>, WTERMSIG(status));  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(WIFSTOPPED(status))&#123;    <span class="comment">//终止前暂停或者等待过  </span></span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;stopped sig: %d\n&quot;</span>, WSTOPSIG(status));   <span class="comment">//kill -19 测试结果  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span>&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;unknow sig\n&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> status;  </span><br><span class="line">    <span class="keyword">pid_t</span> pid;  </span><br><span class="line">    <span class="keyword">if</span>((pid = fork()) &lt; <span class="number">0</span>)&#123;  </span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;fork error&quot;</span>);  </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pid: %d, ppid: %d\n&quot;</span>, getpid(), getppid());  </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">3</span>); <span class="comment">//子进程终止运行  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    wait(&amp;status);      <span class="comment">//父进程阻塞，等待子进程结束并回收  </span></span><br><span class="line">    out_status(status);  <span class="comment">//调用函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;--------------------------\n&quot;</span>);  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((pid = fork()) &lt; <span class="number">0</span>)&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fork error&quot;</span>);  </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pid: %d, ppid: %d\n&quot;</span>, getpid(), getppid());  </span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">3</span>, j = <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">int</span> k = i / j;  <span class="comment">//异常测试  </span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;k: %d\n&quot;</span>, k);  </span><br><span class="line">    &#125;  </span><br><span class="line">    wait(&amp;status);  </span><br><span class="line">    out_status(status);  <span class="comment">//调用函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;--------------------------\n&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span>((pid = fork()) &lt; <span class="number">0</span>)&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fork error&quot;</span>);  </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pid: %d, ppid: %d\n&quot;</span>, getpid(), getppid());  </span><br><span class="line">        pause();  <span class="comment">//暂停测试  </span></span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">do</span>&#123;          <span class="comment">//暂停测试需要用waitpid来捕获暂停的信号，并返回  </span></span><br><span class="line">        pid = waitpid(pid, &amp;status, WNOHANG | WUNTRACED);  </span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;  </span><br><span class="line">            sleep(<span class="number">1</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;<span class="keyword">while</span>(pid == <span class="number">0</span>);  </span><br><span class="line">    out_status(status);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>编译之后，运行hong。</p>
<p>第一个进程停止是子进程调用exit()的正常停止，并且status的宏返回子进程调用exit()时，设置的“3”。</p>
<p> 第二个进程停止是子进程中出现了分母为零的错误，导致进程停止。status的宏返回导致子进程退出的信号值“8”，对应信号SIGFPE，意思是“浮点异常”。</p>
<p>第三个进程停止是通过kill命令给进程发送停止信号“19”，来让子进程停止。这里status的宏返回导致子进程停止的信号值“19”.<br><img src="https://cdn.jsdelivr.net/gh/crownz-sec/Blog_Source@master/img/20200504171023.png"></p>
<p>查找进程并发送终止信号<br><img src="https://cdn.jsdelivr.net/gh/crownz-sec/Blog_Source@master/img/20200504171048.png"></p>
<blockquote>
<p>参考：</p>
<p>[1] <a target="_blank" rel="noopener" href="http://cighao.com/2016/07/15/c-linux-fork">Linux C 中的fork</a></p>
<p>[2] <a target="_blank" rel="noopener" href="https://blog.csdn.net/mybelief321/article/details/9055589.">Linux exec函数族</a></p>
<p>[3] <a target="_blank" rel="noopener" href="https://www.cnblogs.com/zhanggaofeng/p/6073568.html">Linux wait函数解析</a></p>
</blockquote>

  </div>
</article>

    <div class="blog-post-comments">
        <div id="disqus_thread">
            <noscript>Please enable JavaScript to view the comments.</noscript>
        </div>
    </div>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#fork"><span class="toc-number">2.</span> <span class="toc-text">fork()</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD"><span class="toc-number">2.1.</span> <span class="toc-text">功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%E5%8F%8A%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">2.2.</span> <span class="toc-text">函数原型及返回值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA"><span class="toc-number">2.3.</span> <span class="toc-text">代码演示</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#exec"><span class="toc-number">3.</span> <span class="toc-text">exec()</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD-1"><span class="toc-number">3.1.</span> <span class="toc-text">功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%E5%8F%8A%E8%BF%94%E5%9B%9E%E5%80%BC-1"><span class="toc-number">3.2.</span> <span class="toc-text">函数原型及返回值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA-1"><span class="toc-number">3.3.</span> <span class="toc-text">代码演示</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#exit"><span class="toc-number">4.</span> <span class="toc-text">exit()</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD-2"><span class="toc-number">4.1.</span> <span class="toc-text">功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%E5%8F%8A%E8%BF%94%E5%9B%9E%E5%80%BC-2"><span class="toc-number">4.2.</span> <span class="toc-text">函数原型及返回值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA-2"><span class="toc-number">4.3.</span> <span class="toc-text">代码演示</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#wait"><span class="toc-number">5.</span> <span class="toc-text">wait()</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD-3"><span class="toc-number">5.1.</span> <span class="toc-text">功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%E5%8F%8A%E8%BF%94%E5%9B%9E%E5%80%BC-3"><span class="toc-number">5.2.</span> <span class="toc-text">函数原型及返回值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA-3"><span class="toc-number">5.3.</span> <span class="toc-text">代码演示</span></a></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://crownz-sec.github.io/2020/05/04/linux_process_control/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://crownz-sec.github.io/2020/05/04/linux_process_control/&text=Linux中的fork()、exec()、exit()和wati()"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://crownz-sec.github.io/2020/05/04/linux_process_control/&title=Linux中的fork()、exec()、exit()和wati()"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://crownz-sec.github.io/2020/05/04/linux_process_control/&is_video=false&description=Linux中的fork()、exec()、exit()和wati()"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Linux中的fork()、exec()、exit()和wati()&body=Check out this article: https://crownz-sec.github.io/2020/05/04/linux_process_control/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://crownz-sec.github.io/2020/05/04/linux_process_control/&title=Linux中的fork()、exec()、exit()和wati()"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://crownz-sec.github.io/2020/05/04/linux_process_control/&title=Linux中的fork()、exec()、exit()和wati()"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://crownz-sec.github.io/2020/05/04/linux_process_control/&title=Linux中的fork()、exec()、exit()和wati()"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://crownz-sec.github.io/2020/05/04/linux_process_control/&title=Linux中的fork()、exec()、exit()和wati()"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://crownz-sec.github.io/2020/05/04/linux_process_control/&name=Linux中的fork()、exec()、exit()和wati()&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://crownz-sec.github.io/2020/05/04/linux_process_control/&t=Linux中的fork()、exec()、exit()和wati()"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2020-2024
    crownZ
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.2/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->
 
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script> 




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script> 
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->

    <script type="text/javascript">
        var disqus_shortname = 'crownZz';

        (function(){
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        }());
    </script>

<!-- utterances Comments -->

</body>
</html>
