<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="一、古典密码-维吉尼亚密码1.简介​        维吉尼亚密码是由法国密码学家Blaise De Vigenère于1858年提出的一种代换密码，它是多表代换密码的典型代表。 ​        在凯撒密码中，字母表中的每一字母都会作一定的偏移，例如偏移量为3时，A就转换为了D、B转换为了E等等。而维吉尼亚密码，可以看成是由一些偏移量不同的恺撒密码所组成的。 2.算法流程​        维吉尼亚">
<meta property="og:type" content="article">
<meta property="og:title" content="密码学课程设计报告">
<meta property="og:url" content="https://crownz-sec.github.io/2020/01/15/crypto_report/index.html">
<meta property="og:site_name" content="crownZ&#39;s Blog">
<meta property="og:description" content="一、古典密码-维吉尼亚密码1.简介​        维吉尼亚密码是由法国密码学家Blaise De Vigenère于1858年提出的一种代换密码，它是多表代换密码的典型代表。 ​        在凯撒密码中，字母表中的每一字母都会作一定的偏移，例如偏移量为3时，A就转换为了D、B转换为了E等等。而维吉尼亚密码，可以看成是由一些偏移量不同的恺撒密码所组成的。 2.算法流程​        维吉尼亚">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/crownz-sec/Blog_Source@master/img/20200115150531.png#pic_center">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/crownz-sec/Blog_Source@master/img/20200115151548.png#pic_center">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/crownz-sec/Blog_Source@master/img/20200115164436.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/crownz-sec/Blog_Source@master/img/20200115151709.png#pic_center">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/crownz-sec/Blog_Source@master/img/20200115151745.png#pic_center">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/crownz-sec/Blog_Source@master/img/20200115152303.png#pic_center">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/crownz-sec/Blog_Source@master/img/20200115152621.png#pic_center">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/crownz-sec/Blog_Source@master/img/20200115153800.png#pic_center">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/crownz-sec/Blog_Source@master/img/20200115153858.png#pic_center">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/crownz-sec/Blog_Source@master/img/20200115162255.png#pic_center">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/crownz-sec/Blog_Source@master/img/20200115162552.png#pic_center">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/crownz-sec/Blog_Source@master/img/20200115162630.png#pic_center">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/crownz-sec/Blog_Source@master/img/20200115162657.png#pic_center">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/crownz-sec/Blog_Source@master/img/20200115162722.png#pic_center">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/crownz-sec/Blog_Source@master/img/20200115162943.png#pic_center">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/crownz-sec/Blog_Source@master/img/20200115163015.png#pic_center">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/crownz-sec/Blog_Source@master/img/20200115164644.png#pic_center">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/crownz-sec/Blog_Source@master/img/20200115165544.png#pic_center">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/crownz-sec/Blog_Source@master/img/20200115165623.png#pic_center">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/crownz-sec/Blog_Source@master/img/20200115165704.png#pic_center">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/crownz-sec/Blog_Source@master/img/20200115165817.png#pic_center">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/crownz-sec/Blog_Source@master/img/20200115165915.png#pic_center">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/crownz-sec/Blog_Source@master/img/20200115165947.png#pic_center">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/crownz-sec/Blog_Source@master/img/20200115173111.png#pic_center">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/crownz-sec/Blog_Source@master/img/20200115173924.png#pic_center">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/crownz-sec/Blog_Source@master/img/20200115174150.png#pic_center">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/crownz-sec/Blog_Source@master/img/md5.png#pic_center">
<meta property="og:image" content="https://gitee.com/crownz/blog_image/raw/master/20200627161017.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/crownz-sec/Blog_Source@master/img/20200115174345.png#pic_center">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/crownz-sec/Blog_Source@master/img/20200115175812.png#pic_center">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/crownz-sec/Blog_Source@master/img/20200115175838.png#pic_center">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/crownz-sec/Blog_Source@master/img/20200115175918.png#pic_center">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/crownz-sec/Blog_Source@master/img/20200115175958.png#pic_center">
<meta property="article:published_time" content="2020-01-15T08:00:00.000Z">
<meta property="article:modified_time" content="2022-01-16T06:59:37.727Z">
<meta property="article:author" content="crownZ">
<meta property="article:tag" content="学习">
<meta property="article:tag" content="报告">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/crownz-sec/Blog_Source@master/img/20200115150531.png#pic_center">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>密码学课程设计报告</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 6.0.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="Previous post" href="/2020/01/17/BurpSuite_Update/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="Next post" href="/2020/01/15/easy_msf/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://crownz-sec.github.io/2020/01/15/crypto_report/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://crownz-sec.github.io/2020/01/15/crypto_report/&text=密码学课程设计报告"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://crownz-sec.github.io/2020/01/15/crypto_report/&title=密码学课程设计报告"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://crownz-sec.github.io/2020/01/15/crypto_report/&is_video=false&description=密码学课程设计报告"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=密码学课程设计报告&body=Check out this article: https://crownz-sec.github.io/2020/01/15/crypto_report/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://crownz-sec.github.io/2020/01/15/crypto_report/&title=密码学课程设计报告"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://crownz-sec.github.io/2020/01/15/crypto_report/&title=密码学课程设计报告"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://crownz-sec.github.io/2020/01/15/crypto_report/&title=密码学课程设计报告"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://crownz-sec.github.io/2020/01/15/crypto_report/&title=密码学课程设计报告"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://crownz-sec.github.io/2020/01/15/crypto_report/&name=密码学课程设计报告&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://crownz-sec.github.io/2020/01/15/crypto_report/&t=密码学课程设计报告"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81-%E7%BB%B4%E5%90%89%E5%B0%BC%E4%BA%9A%E5%AF%86%E7%A0%81"><span class="toc-number">1.</span> <span class="toc-text">一、古典密码-维吉尼亚密码</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%AE%80%E4%BB%8B"><span class="toc-number">1.1.</span> <span class="toc-text">1.简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B"><span class="toc-number">1.2.</span> <span class="toc-text">2.算法流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.3.</span> <span class="toc-text">3.算法实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1%E6%98%8E%E6%96%87%E9%A2%84%E5%A4%84%E7%90%86"><span class="toc-number">1.3.1.</span> <span class="toc-text">3.1明文预处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2%E5%AF%86%E9%92%A5%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E4%B8%BA%E6%95%B0%E5%AD%97%E5%88%97%E8%A1%A8"><span class="toc-number">1.3.2.</span> <span class="toc-text">3.2密钥字符串转为数字列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3%E5%8A%A0%E5%AF%86%E8%BF%87%E7%A8%8B"><span class="toc-number">1.3.3.</span> <span class="toc-text">3.3加密过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4%E8%A7%A3%E5%AF%86%E8%BF%87%E7%A8%8B"><span class="toc-number">1.3.4.</span> <span class="toc-text">3.4解密过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%AE%97%E6%B3%95%E9%AA%8C%E8%AF%81"><span class="toc-number">1.4.</span> <span class="toc-text">4.算法验证</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E7%AE%97%E6%B3%95%E7%A0%B4%E8%A7%A3"><span class="toc-number">1.5.</span> <span class="toc-text">5.算法破解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1%E7%A1%AE%E5%AE%9A%E5%AF%86%E9%92%A5%E9%95%BF%E5%BA%A6"><span class="toc-number">1.5.1.</span> <span class="toc-text">5.1确定密钥长度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2%E7%A1%AE%E5%AE%9A%E5%AF%86%E9%92%A5"><span class="toc-number">1.5.2.</span> <span class="toc-text">5.2确定密钥</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3%E6%81%A2%E5%A4%8D%E6%98%8E%E6%96%87%E5%B9%B6%E9%AA%8C%E8%AF%81"><span class="toc-number">1.5.3.</span> <span class="toc-text">5.3恢复明文并验证</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-number">1.6.</span> <span class="toc-text">6.算法分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E9%80%89%E6%8B%A9%E5%B7%A5%E5%85%B7%E5%8E%9F%E5%9B%A0"><span class="toc-number">1.7.</span> <span class="toc-text">7.选择工具原因</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E5%AE%9E%E7%8E%B0%E9%9A%BE%E7%82%B9"><span class="toc-number">1.8.</span> <span class="toc-text">8.实现难点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%BA%8F%E5%88%97%E5%AF%86%E7%A0%81-%E7%BA%BF%E6%80%A7%E5%8F%8D%E9%A6%88%E7%A7%BB%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">2.</span> <span class="toc-text">二、序列密码-线性反馈移位寄存器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%AE%80%E4%BB%8B-1"><span class="toc-number">2.1.</span> <span class="toc-text">1.简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.2.</span> <span class="toc-text">2.算法实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1%E9%80%89%E5%AE%9A%E5%88%9D%E5%A7%8B%E5%BA%8F%E5%88%97%E5%92%8C%E7%89%B9%E5%BE%81%E5%A4%9A%E9%A1%B9%E5%BC%8F"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.1选定初始序列和特征多项式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2%E7%BA%BF%E6%80%A7%E5%8F%8D%E9%A6%88%E7%A7%BB%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.2线性反馈移位寄存器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%AE%97%E6%B3%95%E9%AA%8C%E8%AF%81"><span class="toc-number">2.3.</span> <span class="toc-text">3.算法验证</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%AE%9E%E7%8E%B0%E9%9A%BE%E7%82%B9"><span class="toc-number">2.4.</span> <span class="toc-text">4.实现难点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81-DES%E7%AE%97%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">三、对称密码-DES算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%AE%80%E4%BB%8B-2"><span class="toc-number">3.1.</span> <span class="toc-text">1.简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B-1"><span class="toc-number">3.2.</span> <span class="toc-text">2.算法流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1%E5%88%9D%E5%A7%8B%E7%BD%AE%E6%8D%A2%E5%92%8C%E9%80%86%E5%88%9D%E5%A7%8B%E7%BD%AE%E6%8D%A2"><span class="toc-number">3.2.1.</span> <span class="toc-text">2.1初始置换和逆初始置换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2%E8%BD%AE%E5%87%BD%E6%95%B0"><span class="toc-number">3.2.2.</span> <span class="toc-text">2.2轮函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3%E5%AF%86%E9%92%A5%E7%BC%96%E6%8E%92"><span class="toc-number">3.2.3.</span> <span class="toc-text">2.3密钥编排</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0-1"><span class="toc-number">3.3.</span> <span class="toc-text">3.算法实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1%E5%88%9D%E5%A7%8B%E7%BD%AE%E6%8D%A2%E5%92%8C%E9%80%86%E5%88%9D%E5%A7%8B%E7%BD%AE%E6%8D%A2"><span class="toc-number">3.3.1.</span> <span class="toc-text">3.1初始置换和逆初始置换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-E%E7%9B%92%E6%89%A9%E5%B1%95"><span class="toc-number">3.3.2.</span> <span class="toc-text">3.2 E盒扩展</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E5%AF%86%E9%92%A5%E5%8A%A0"><span class="toc-number">3.3.3.</span> <span class="toc-text">3.3 密钥加</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-S%E7%9B%92%E4%BB%A3%E6%8D%A2"><span class="toc-number">3.3.4.</span> <span class="toc-text">3.4 S盒代换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-P%E7%9B%92%E7%BD%AE%E6%8D%A2"><span class="toc-number">3.3.5.</span> <span class="toc-text">3.5 P盒置换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6%E5%AD%90%E5%AF%86%E9%92%A5%E7%94%9F%E6%88%90"><span class="toc-number">3.3.6.</span> <span class="toc-text">3.6子密钥生成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7%E5%8D%95%E6%AC%A1%E5%8A%A0%E5%AF%86%E8%BF%87%E7%A8%8B"><span class="toc-number">3.3.7.</span> <span class="toc-text">3.7单次加密过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-8%E5%8D%95%E6%AC%A1%E8%A7%A3%E5%AF%86%E8%BF%87%E7%A8%8B"><span class="toc-number">3.3.8.</span> <span class="toc-text">3.8单次解密过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%AE%97%E6%B3%95%E9%AA%8C%E8%AF%81-1"><span class="toc-number">3.4.</span> <span class="toc-text">4.算法验证</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-number">3.5.</span> <span class="toc-text">5.算法分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1%E4%BA%92%E8%A1%A5%E6%80%A7"><span class="toc-number">3.5.1.</span> <span class="toc-text">5.1互补性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2%E5%BC%B1%E5%AF%86%E9%92%A5"><span class="toc-number">3.5.2.</span> <span class="toc-text">5.2弱密钥</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3%E8%BF%AD%E4%BB%A3%E8%BD%AE%E6%95%B0"><span class="toc-number">3.5.3.</span> <span class="toc-text">5.3迭代轮数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4%E5%AF%86%E9%92%A5%E9%95%BF%E5%BA%A6"><span class="toc-number">3.5.4.</span> <span class="toc-text">5.4密钥长度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E9%80%89%E6%8B%A9%E5%B7%A5%E5%85%B7%E5%8E%9F%E5%9B%A0"><span class="toc-number">3.6.</span> <span class="toc-text">6.选择工具原因</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E5%AE%9E%E7%8E%B0%E9%9A%BE%E7%82%B9"><span class="toc-number">3.7.</span> <span class="toc-text">7.实现难点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81-RSA%E7%AE%97%E6%B3%95"><span class="toc-number">4.</span> <span class="toc-text">四、非对称密码-RSA算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%AE%80%E4%BB%8B-3"><span class="toc-number">4.1.</span> <span class="toc-text">1.简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B-2"><span class="toc-number">4.2.</span> <span class="toc-text">2.算法流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1%E5%AF%86%E9%92%A5%E7%94%9F%E6%88%90"><span class="toc-number">4.2.1.</span> <span class="toc-text">2.1密钥生成</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0-2"><span class="toc-number">4.3.</span> <span class="toc-text">3.算法实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1%E7%94%9F%E6%88%90%E5%A4%A7%E5%A5%87%E6%95%B0"><span class="toc-number">4.3.1.</span> <span class="toc-text">3.1生成大奇数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2%E5%BF%AB%E9%80%9F%E5%B9%82"><span class="toc-number">4.3.2.</span> <span class="toc-text">3.2快速幂</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3%E7%B4%A0%E6%80%A7%E6%A3%80%E9%AA%8C"><span class="toc-number">4.3.3.</span> <span class="toc-text">3.3素性检验</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4%E4%BA%A7%E7%94%9F%E5%A4%A7%E7%B4%A0%E6%95%B0"><span class="toc-number">4.3.4.</span> <span class="toc-text">3.4产生大素数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5%E6%B1%82%E6%A8%A1%E9%80%86"><span class="toc-number">4.3.5.</span> <span class="toc-text">3.5求模逆</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%AE%97%E6%B3%95%E9%AA%8C%E8%AF%81-2"><span class="toc-number">4.4.</span> <span class="toc-text">4.算法验证</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90-1"><span class="toc-number">4.5.</span> <span class="toc-text">5.算法分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1%E5%9B%A0%E5%AD%90%E5%88%86%E8%A7%A3%E6%B3%95"><span class="toc-number">4.5.1.</span> <span class="toc-text">5.1因子分解法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2%E5%85%B1%E6%A8%A1%E6%94%BB%E5%87%BB"><span class="toc-number">4.5.2.</span> <span class="toc-text">5.2共模攻击</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3%E4%BD%8E%E5%8A%A0%E5%AF%86%E6%8C%87%E6%95%B0%E6%94%BB%E5%87%BB"><span class="toc-number">4.5.3.</span> <span class="toc-text">5.3低加密指数攻击</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4%E5%BE%AA%E7%8E%AF%E6%94%BB%E5%87%BB"><span class="toc-number">4.5.4.</span> <span class="toc-text">5.4循环攻击</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E9%80%89%E6%8B%A9%E5%B7%A5%E5%85%B7%E5%8E%9F%E5%9B%A0-1"><span class="toc-number">4.6.</span> <span class="toc-text">6.选择工具原因</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E5%AE%9E%E7%8E%B0%E9%9A%BE%E7%82%B9-1"><span class="toc-number">4.7.</span> <span class="toc-text">7.实现难点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81Hash%E5%87%BD%E6%95%B0-MD5%E7%AE%97%E6%B3%95"><span class="toc-number">5.</span> <span class="toc-text">五、Hash函数-MD5算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%AE%80%E4%BB%8B-4"><span class="toc-number">5.1.</span> <span class="toc-text">1.简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B-3"><span class="toc-number">5.2.</span> <span class="toc-text">2.算法流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1%E9%99%84%E5%8A%A0%E5%A1%AB%E5%85%85%E4%BD%8D"><span class="toc-number">5.2.1.</span> <span class="toc-text">2.1附加填充位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2%E5%88%9D%E5%A7%8B%E5%8C%96%E9%93%BE%E6%8E%A5%E5%8F%98%E9%87%8F"><span class="toc-number">5.2.2.</span> <span class="toc-text">2.2初始化链接变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3%E5%88%86%E7%BB%84%E5%A4%84%E7%90%86"><span class="toc-number">5.2.3.</span> <span class="toc-text">2.3分组处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4%E6%AD%A5%E5%87%BD%E6%95%B0"><span class="toc-number">5.2.4.</span> <span class="toc-text">2.4步函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0-3"><span class="toc-number">5.3.</span> <span class="toc-text">3.算法实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1%E9%99%84%E5%8A%A0%E5%A1%AB%E5%85%85%E4%BD%8D"><span class="toc-number">5.3.1.</span> <span class="toc-text">3.1附加填充位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2%E5%88%86%E7%BB%84%E5%A4%84%E7%90%86%E5%8F%8A%E6%AD%A5%E5%87%BD%E6%95%B0"><span class="toc-number">5.3.2.</span> <span class="toc-text">3.2分组处理及步函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-number">5.3.3.</span> <span class="toc-text">3.3输出结果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%AE%97%E6%B3%95%E9%AA%8C%E8%AF%81-3"><span class="toc-number">5.4.</span> <span class="toc-text">4.算法验证</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90-2"><span class="toc-number">5.5.</span> <span class="toc-text">5.算法分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E9%80%89%E6%8B%A9%E5%B7%A5%E5%85%B7%E5%8E%9F%E5%9B%A0-2"><span class="toc-number">5.6.</span> <span class="toc-text">6.选择工具原因</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E5%AE%9E%E7%8E%B0%E9%9A%BE%E7%82%B9-2"><span class="toc-number">5.7.</span> <span class="toc-text">7.实现难点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E7%BB%BC%E5%90%88%E5%AE%9E%E9%AA%8C"><span class="toc-number">6.</span> <span class="toc-text">六、综合实验</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%AE%80%E4%BB%8B-5"><span class="toc-number">6.1.</span> <span class="toc-text">1.简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B-4"><span class="toc-number">6.2.</span> <span class="toc-text">2.算法流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0-4"><span class="toc-number">6.3.</span> <span class="toc-text">3.算法实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81"><span class="toc-number">6.3.1.</span> <span class="toc-text">3.1身份认证</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2%E5%8A%A0%E5%AF%86%E6%96%87%E4%BB%B6%E5%92%8C%E5%AF%B9%E7%A7%B0%E5%AF%86%E9%92%A5"><span class="toc-number">6.3.2.</span> <span class="toc-text">3.2加密文件和对称密钥</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3%E8%A7%A3%E5%AF%86%E5%AF%B9%E7%A7%B0%E5%AF%86%E9%92%A5%E5%92%8C%E6%96%87%E4%BB%B6"><span class="toc-number">6.3.3.</span> <span class="toc-text">3.3解密对称密钥和文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%AE%97%E6%B3%95%E9%AA%8C%E8%AF%81-4"><span class="toc-number">6.4.</span> <span class="toc-text">4.算法验证</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81"><span class="toc-number">6.4.1.</span> <span class="toc-text">4.1身份认证</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2%E5%8A%A0%E5%AF%86%E6%96%87%E4%BB%B6%E5%92%8C%E5%AF%B9%E7%A7%B0%E5%AF%86%E9%92%A5"><span class="toc-number">6.4.2.</span> <span class="toc-text">4.2加密文件和对称密钥</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3%E8%A7%A3%E5%AF%86%E5%AF%B9%E7%A7%B0%E5%AF%86%E9%92%A5%E5%92%8C%E6%96%87%E4%BB%B6"><span class="toc-number">6.4.3.</span> <span class="toc-text">4.3解密对称密钥和文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90-3"><span class="toc-number">6.5.</span> <span class="toc-text">5.算法分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E9%80%89%E6%8B%A9%E5%B7%A5%E5%85%B7%E5%8E%9F%E5%9B%A0-3"><span class="toc-number">6.6.</span> <span class="toc-text">6.选择工具原因</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E5%AE%9E%E7%8E%B0%E9%9A%BE%E7%82%B9-3"><span class="toc-number">6.7.</span> <span class="toc-text">7.实现难点</span></a></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        密码学课程设计报告
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">crownZ</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2020-01-15T08:00:00.000Z" itemprop="datePublished">2020-01-15</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fas fa-archive"></i>
        <a class="category-link" href="/categories/Crypto/">Crypto</a>
    </div>


      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link-link" href="/tags/%E5%AD%A6%E4%B9%A0/" rel="tag">学习</a>, <a class="tag-link-link" href="/tags/%E6%8A%A5%E5%91%8A/" rel="tag">报告</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h1 id="一、古典密码-维吉尼亚密码"><a href="#一、古典密码-维吉尼亚密码" class="headerlink" title="一、古典密码-维吉尼亚密码"></a>一、古典密码-维吉尼亚密码</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p>​        维吉尼亚密码是由法国密码学家Blaise De Vigenère于1858年提出的一种代换密码，它是多表代换密码的典型代表。</p>
<p>​        在凯撒密码中，字母表中的每一字母都会作一定的偏移，例如偏移量为3时，A就转换为了D、B转换为了E等等。而维吉尼亚密码，可以看成是由一些偏移量不同的恺撒密码所组成的。</p>
<h2 id="2-算法流程"><a href="#2-算法流程" class="headerlink" title="2.算法流程"></a>2.算法流程</h2><p>​        维吉尼亚加密需要先选定一个密钥，再将明文和密钥的每个字符都按字母表顺序，转换为数字。然后，把明文按密钥字的长度分组，使用密钥字母对应数字加上明文字母对应数字之后，进行模26的运算，求余，即为加密结果。</p>
<p>​        为了快速生成密码，可以使用表格法。这一表格包括26行字母表，每一行都由前一行向左偏移一位得到。具体使用哪一行字母表进行编译是基于密钥进行的，在过程中会不断地变换。</p>
<p>​        加密过程：明文字母p对应的列和密钥字母对应的行的交叉点，就是加密后的密文字母c。</p>
<p>​        解密过程：在密钥字母k对应的行，找到相应的密文字母c，则c所在列对应的明文字母即为p。</p>
<p><img src="https://cdn.jsdelivr.net/gh/crownz-sec/Blog_Source@master/img/20200115150531.png#pic_center"></p>
<div align=center> 维吉尼亚表</div> 

<h2 id="3-算法实现"><a href="#3-算法实现" class="headerlink" title="3.算法实现"></a>3.算法实现</h2><h3 id="3-1明文预处理"><a href="#3-1明文预处理" class="headerlink" title="3.1明文预处理"></a>3.1明文预处理</h3><p>​        因为维吉尼亚密码只能对英文字母进行处理，所以先用正则表达式去匹配文本中的非字母，然后再去除这些字符，即得到了纯英文字符明文。<br> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">PreTreat</span>():</span>  </span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;/Users/crownz/Crypto/1.Vigenere/plain.txt&quot;</span>,<span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:  </span><br><span class="line">        plaintext = f.read()  </span><br><span class="line">    pattern = re.<span class="built_in">compile</span>(<span class="string">&#x27;[\n]|\d|\W&#x27;</span>)  <span class="comment">#匹配非字母  </span></span><br><span class="line">    f_plain = re.sub(pattern,<span class="string">&#x27;&#x27;</span>,plaintext).lower()  </span><br><span class="line">    <span class="keyword">return</span> f_plain  </span><br></pre></td></tr></table></figure></p>
<h3 id="3-2密钥字符串转为数字列表"><a href="#3-2密钥字符串转为数字列表" class="headerlink" title="3.2密钥字符串转为数字列表"></a>3.2密钥字符串转为数字列表</h3><p>​         因为要使用密钥字符对应数字与明文字符对应数字相加来模26，这里将密钥字符先转换为数字列表，方便下面运用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">key_to_num</span>(<span class="params">key</span>):</span>  </span><br><span class="line">    key_list=<span class="built_in">list</span>(key)  </span><br><span class="line">    num_key_list=[]  </span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> key_list:  </span><br><span class="line">        num_key=<span class="built_in">ord</span>(key)-<span class="number">97</span>  </span><br><span class="line">        num_key_list.append(num_key)  </span><br><span class="line">    <span class="keyword">return</span> num_key_list  </span><br></pre></td></tr></table></figure>

<h3 id="3-3加密过程"><a href="#3-3加密过程" class="headerlink" title="3.3加密过程"></a>3.3加密过程</h3><p>​        在加密中，先将明文预处理，并将密钥转换为数字列表。之后，遍历明文，依次对每个明文数字减去a的assic码，再加上密钥字的数字后，模26取余，将余数转换为相应密文字符。将所有密文字符相连接，返回密文。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt</span>(<span class="params">key</span>):</span>  </span><br><span class="line">    plaintext = PreTreat()  </span><br><span class="line">    num_key_list = key_to_num(key)  </span><br><span class="line">    ciphertext=<span class="string">&#x27;&#x27;</span>  </span><br><span class="line">    k=<span class="number">0</span>  </span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> plaintext:  </span><br><span class="line">        <span class="keyword">if</span> k == <span class="built_in">len</span>(num_key_list):  </span><br><span class="line">            k = <span class="number">0</span>  </span><br><span class="line">        num_p = <span class="built_in">ord</span>(p)-<span class="number">97</span>  </span><br><span class="line">        cipher = (num_p+num_key_list[k]) % <span class="number">26</span>  </span><br><span class="line">        cipher = <span class="built_in">chr</span>(cipher+<span class="number">97</span>-<span class="number">32</span>)  </span><br><span class="line">        ciphertext = ciphertext + cipher  </span><br><span class="line">        k += <span class="number">1</span>  </span><br><span class="line">    <span class="keyword">return</span> ciphertext </span><br></pre></td></tr></table></figure>

<h3 id="3-4解密过程"><a href="#3-4解密过程" class="headerlink" title="3.4解密过程"></a>3.4解密过程</h3><p>​         先将所有字符转为小写，并将密钥转为数字列表。之后，遍历密文，依次对每个密文数字减去a的assic码，在加上密钥字的数字后，判断正负，负数加上26，将结果转换为相应明文字符。将所有明文字符连接，返回明文。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt</span>(<span class="params">key</span>):</span>  </span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;/Users/crownz/Crypto/1.Vigenere/cipher.txt&quot;</span>) <span class="keyword">as</span> f:  </span><br><span class="line">        ciphertext = f.read().lower()  </span><br><span class="line">    num_key = key_to_num(key)  </span><br><span class="line">    plaintext=<span class="string">&#x27;&#x27;</span>  </span><br><span class="line">    k = <span class="number">0</span>  </span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> ciphertext:  </span><br><span class="line">        <span class="keyword">if</span> k == <span class="built_in">len</span>(num_key):  </span><br><span class="line">            k = <span class="number">0</span>  </span><br><span class="line">        result = <span class="built_in">ord</span>(c)-<span class="number">97</span> - num_key[k]  </span><br><span class="line">        <span class="keyword">if</span> result &lt; <span class="number">0</span>:  </span><br><span class="line">            result = <span class="number">26</span> + result  </span><br><span class="line">        plain = result  </span><br><span class="line">        plain = <span class="built_in">chr</span>(plain+<span class="number">97</span>)  </span><br><span class="line">        plaintext = plaintext + plain  </span><br><span class="line">        k += <span class="number">1</span>  </span><br><span class="line">    <span class="keyword">return</span> plaintext  </span><br></pre></td></tr></table></figure>

<h2 id="4-算法验证"><a href="#4-算法验证" class="headerlink" title="4.算法验证"></a>4.算法验证</h2><p>​        先找到一篇英文文章，用来加密。</p>
<p><img src="https://cdn.jsdelivr.net/gh/crownz-sec/Blog_Source@master/img/20200115151548.png#pic_center"></p>
<p>​        读入文件，选定密钥为“ilovecumt”，再使用加密算法，加密文章，输出密文。</p>
<p><img src="https://cdn.jsdelivr.net/gh/crownz-sec/Blog_Source@master/img/20200115164436.png"></p>
<p>​        然后，再用自己的解密算法解密。在控制台中，可以看到跟明文意思相符的一连串字符。</p>
<p><img src="https://cdn.jsdelivr.net/gh/crownz-sec/Blog_Source@master/img/20200115151709.png#pic_center"></p>
<p>​        为了验证自己的算法，再去找一个维吉尼亚解密的在线网站解密。</p>
<p><img src="https://cdn.jsdelivr.net/gh/crownz-sec/Blog_Source@master/img/20200115151745.png#pic_center"></p>
<p>​         可以看到，下面的解密是有明文意思的连续字符串，只不过都是大写的。</p>
<h2 id="5-算法破解"><a href="#5-算法破解" class="headerlink" title="5.算法破解"></a>5.算法破解</h2><p>​        维吉尼亚密码是一个多表代换密码，它打破了原语言的字符出现规律，比单表代换密码分析要复杂很多，但仍然有分析破解它的方法。</p>
<p>​        维吉尼亚密码破解的分析方法主要分为三步：</p>
<p>​        ①重合指数法确定密钥长度</p>
<p>​        ②拟重合指数法确定密钥</p>
<p>​        ③根据确定的密钥来恢复明文</p>
<h3 id="5-1确定密钥长度"><a href="#5-1确定密钥长度" class="headerlink" title="5.1确定密钥长度"></a>5.1确定密钥长度</h3><p>​        设一门语言由n个字母组成，每个字母出现的概率为 Pi ，则重合指数是指两个元素随机相同的概率之和，记作CI=∑Pi2 (1&lt;= i &lt;= n)。</p>
<p>​        经分析，英文中，一段文字是随机的话，CI≈0.038；如果这段文字是有意义的，那么CI≈0.065。实际上计算CI时，应该用这个公式：</p>
<p><img src="https://cdn.jsdelivr.net/gh/crownz-sec/Blog_Source@master/img/20200115152303.png#pic_center"></p>
<p>（L：密文长度；fi：在密文中的出现次数；n：这门语言的字母个数）</p>
<p>​        然后算出不同密钥长度下，遍历该密钥长度区间，来计算每个密钥长度下的CI’的值。之后，去找出最接近0.065的值，其对应的密钥长度即为最可能的密钥长度。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_keylen</span>():</span>   <span class="comment">#猜解密钥长度  </span></span><br><span class="line">    flist=[]  </span><br><span class="line">    ave_flist=[]  </span><br><span class="line">    len_list=[]  </span><br><span class="line">    result=[]  </span><br><span class="line">    res=[]  </span><br><span class="line">    initial_text=<span class="built_in">open</span>(<span class="string">&quot;/Users/crownz/Crypto/1.Vigenere/cipher.txt&quot;</span>,<span class="string">&quot;r&quot;</span>)</span><br><span class="line">    simplified_text=initial_text.read()<span class="comment">#防止len出错</span></span><br><span class="line">    letter_cnt=<span class="built_in">len</span>(simplified_text)<span class="comment">#英文字母总个数  </span></span><br><span class="line">    simp_text=<span class="built_in">map</span>(all_lower,simplified_text)<span class="comment">#都换成小写字母  </span></span><br><span class="line">    text_list=<span class="built_in">list</span>(simp_text)<span class="comment">#将简化的文本列表化  </span></span><br><span class="line">    <span class="keyword">for</span> key_len <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,<span class="number">50</span>):   <span class="comment">#在密钥可能的长度范围里面找  </span></span><br><span class="line">        len_list.append(key_len)      </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(key_len):  </span><br><span class="line">            templist=text_list[i::key_len]  <span class="comment">#按密钥长度分组  </span></span><br><span class="line">            sqcnt_list=[]  </span><br><span class="line">            temp_len=<span class="built_in">len</span>(templist)<span class="comment">#分组字母个数  </span></span><br><span class="line">            once_list=simplifiy_list(templist)<span class="comment">#对当前分组去重复  </span></span><br><span class="line">            <span class="keyword">for</span> letter <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(once_list)):  </span><br><span class="line">                cnt=templist.count(once_list[letter])<span class="comment">#在templist出现的次数  </span></span><br><span class="line">                sqcnt=cnt*(cnt-<span class="number">1</span>)  </span><br><span class="line">                sqcnt_list.append(sqcnt)<span class="comment">#存放的都是sqcnt  </span></span><br><span class="line">            flist.append(add_the_list(sqcnt_list)/(temp_len*(temp_len-<span class="number">1</span>)))  </span><br><span class="line">        ave_fre=add_the_list(flist)/<span class="built_in">len</span>(flist)  </span><br><span class="line">        ave_flist.append(ave_fre)  </span><br><span class="line">    res=<span class="built_in">list</span>(<span class="built_in">zip</span>(len_list,(<span class="built_in">list</span>(<span class="built_in">map</span>(sub_stdfre,ave_flist)))))  </span><br><span class="line">    result=<span class="built_in">sorted</span>(res, key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>]) </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;最有可能的前十个密钥长度及其对应频率和0.065差值为：&quot;</span>)  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):  </span><br><span class="line">        <span class="built_in">print</span>(result[i])  </span><br></pre></td></tr></table></figure>

<p>​        当程序运行到这一步，可以看到跟0.065最相近的前10个密钥长度。</p>
<p><img src="https://cdn.jsdelivr.net/gh/crownz-sec/Blog_Source@master/img/20200115152621.png#pic_center"></p>
<h3 id="5-2确定密钥"><a href="#5-2确定密钥" class="headerlink" title="5.2确定密钥"></a>5.2确定密钥</h3><p>​        在确定密钥长度之后，就可以根据拟重合指数法，来确定密钥。根据密钥长度来确定密文分组，然后，分别遍历每个密文字符的可能取值，以此来恢复该组明文，并计算相应的重合指数。将每组最高重合指数下对应的数字转换为字符连接，即得到相应的密钥。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Crack_key</span>(<span class="params">text,length</span>):</span>   </span><br><span class="line">    key = []   </span><br><span class="line">    array =makelist(text,length)  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):  </span><br><span class="line">        flist = f_list([row[i] <span class="keyword">for</span> row <span class="keyword">in</span> array])  </span><br><span class="line">        multi = []   </span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">26</span>):  </span><br><span class="line">            Sum = <span class="number">0.0</span>  </span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">26</span>):  </span><br><span class="line">                Sum += freq[k]*flist[k]  </span><br><span class="line">            multi.append(Sum)  </span><br><span class="line">            flist = flist[<span class="number">1</span>:]+flist[:<span class="number">1</span>]  </span><br><span class="line">        n = <span class="number">100</span>  </span><br><span class="line">        ch = <span class="string">&#x27;&#x27;</span>  </span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(multi)):  </span><br><span class="line">             <span class="keyword">if</span> <span class="built_in">abs</span>(multi[j] - <span class="number">0.065</span>)&lt;n:   </span><br><span class="line">                 n = <span class="built_in">abs</span>(multi[j] -<span class="number">0.065</span>)  </span><br><span class="line">                 ch = <span class="built_in">chr</span>(j+<span class="number">97</span>)  </span><br><span class="line">        key.append(ch)  </span><br><span class="line">    <span class="keyword">return</span> key  </span><br></pre></td></tr></table></figure>

<p>​          运用上一步得到的密钥长度9，下面看到猜测的密钥为“ilovecumt”。</p>
<p><img src="https://cdn.jsdelivr.net/gh/crownz-sec/Blog_Source@master/img/20200115153800.png#pic_center">  </p>
<h3 id="5-3恢复明文并验证"><a href="#5-3恢复明文并验证" class="headerlink" title="5.3恢复明文并验证"></a>5.3恢复明文并验证</h3><p>​        由上一步得到密钥为“ilovecumt”，将密钥列表连接为字符串后，调用之前写好的解密函数，就可以得到明文。因为，我们知道猜测密钥就是正确的，解密得到的明文也就是正确的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/crownz-sec/Blog_Source@master/img/20200115153858.png#pic_center"></p>
<h2 id="6-算法分析"><a href="#6-算法分析" class="headerlink" title="6.算法分析"></a>6.算法分析</h2><p>​        维吉尼亚密钥是典型的多表代换密码，通过多表代换，将明文的统计特性通过多个表的平均作用隐藏起来，相较于单表代换密码，增大了破解的难度。</p>
<p>​        对所有多表密码的破译都是以字母频率为基础的，这里对维吉尼亚的分析仍不例外，只是直接的频率分析并不适用。通过卡西斯基试验或者就可以得到密钥长度，得到密钥长度，密钥就可以看作是多个凯撒密码结合到一起，每一个都可单独破解，就像上面的破解步骤。</p>
<p>​        从维吉尼亚密码被创造出来的16世纪来说，那时人们并没有相应的分析方法，也就认为它是无法破解的，乃至往后1-2个世纪都有人认为它是足够安全的。直到19世纪，卡西斯基完全破解维吉尼亚密码并发表相关方法。</p>
<p>​        就现在来说，因为相关分析方法的公布，维吉尼亚密码是不安全的，个人通过计算机就可破解，没有安全性可言。</p>
<h2 id="7-选择工具原因"><a href="#7-选择工具原因" class="headerlink" title="7.选择工具原因"></a>7.选择工具原因</h2><p>​        以前一直想学习python，因为深知python的方便有效（对于编程人员来说），但一直又没有实践。曾看过一段时间的python书籍，练过相关小实例，但终究只浮于表面，做完就忘，很不深入，没有进展。所以，在密码学课程设计刚开始时，就决定要用python做完所有实验 ，不会就查，就问，去在实践中锻炼python的使用。</p>
<p>​        现在看来，那句话挺不错的，“人生苦短，我用Python”。python的确很方便易用，通过这里锻练的能力会更多地应用在其他方面。</p>
<h2 id="8-实现难点"><a href="#8-实现难点" class="headerlink" title="8.实现难点"></a>8.实现难点</h2><p>​        实验的难点在于维吉尼亚破解方法的理解，并将相应数学公式转换为相应的代码，出错也只能一步步调了。同时，也可以去看别人代码，看他们在程序的某一步是用什么函数和方法来处理的，能解决一些很困扰人的问题，比如类型不匹配，这个函数不能那样操作等。通过这个过程，能学习到很多。</p>
<h1 id="二、序列密码-线性反馈移位寄存器"><a href="#二、序列密码-线性反馈移位寄存器" class="headerlink" title="二、序列密码-线性反馈移位寄存器"></a>二、序列密码-线性反馈移位寄存器</h1><h2 id="1-简介-1"><a href="#1-简介-1" class="headerlink" title="1.简介"></a>1.简介</h2><p>​        反馈移位寄存器由移位寄存器和反馈函数组成。移位寄存器是由位组成的序列，每次移位寄存器中所有位右移一位，新的最左端的位根据寄存器中的某些位计算来得到，反馈函数用来计算新的最左端位。</p>
<p>​        而线性移位寄存器就是采用线性函数来作为反馈函数的反馈移位寄存器。</p>
<h2 id="2-算法实现"><a href="#2-算法实现" class="headerlink" title="2.算法实现"></a>2.算法实现</h2><p>​        在这里只是实现一个简单线性移位寄存器，没有什么明确的流程，只是编写一个可以移位并加有反馈的寄存器。所以并没有什么具体的算法流程，直接编写就可以。</p>
<h3 id="2-1选定初始序列和特征多项式"><a href="#2-1选定初始序列和特征多项式" class="headerlink" title="2.1选定初始序列和特征多项式"></a>2.1选定初始序列和特征多项式</h3><p>​        因为要对一个序列进行移位那就先选定一个初始序列和一个16次的特征多项式，以再之后验证周期。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">init_ = <span class="string">&#x27;1000000000000000&#x27;</span>    <span class="comment">#初始序列  </span></span><br><span class="line">tap =  <span class="string">&#x27;1000000000010101&#x27;</span>     <span class="comment">#特征多项式二进制  </span></span><br></pre></td></tr></table></figure>
<h3 id="2-2线性反馈移位寄存器"><a href="#2-2线性反馈移位寄存器" class="headerlink" title="2.2线性反馈移位寄存器"></a>2.2线性反馈移位寄存器</h3><p>​        开始设置好寄存器初始序列全局变量，抽头序列，再初始化一个跟寄存器长度一样的新列表。sum用来计数初始序列中1的数量，之后将sum对2取余作为反馈函数，算出左边新一位的值。最后，返回新的寄存器序列。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lfsr</span>(<span class="params">init,tap</span>):</span>  </span><br><span class="line">    <span class="keyword">global</span> init_  <span class="comment">#全局变量，以改变寄存器序列</span></span><br><span class="line">    array_init_bin = <span class="built_in">list</span>(init)  </span><br><span class="line">    tap = <span class="built_in">list</span>(tap)   <span class="comment">#抽头序列</span></span><br><span class="line">  </span><br><span class="line">    array_new = <span class="string">&#x27;0&#x27;</span>*<span class="built_in">len</span>(array_init_bin)  </span><br><span class="line">    array_new = <span class="built_in">list</span>(array_new) <span class="comment">#再初始化一个相同长度序列  </span></span><br><span class="line">  </span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span>  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(array_new)):  </span><br><span class="line">        <span class="keyword">if</span> tap[i] == <span class="string">&#x27;1&#x27;</span>:  </span><br><span class="line">            <span class="built_in">sum</span> += <span class="built_in">int</span>(array_init_bin[i])   </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(array_new)):  </span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span> :  </span><br><span class="line">            array_new[i] = <span class="built_in">str</span>(<span class="built_in">sum</span> % <span class="number">2</span>)<span class="comment">#反馈函数  </span></span><br><span class="line">        <span class="keyword">else</span> :  <span class="comment">#其他位不做处理</span></span><br><span class="line">            array_new[i] = array_init_bin[i-<span class="number">1</span>]  </span><br><span class="line">    init_ = <span class="string">&quot;&quot;</span>.join(array_new)  </span><br></pre></td></tr></table></figure>
<h2 id="3-算法验证"><a href="#3-算法验证" class="headerlink" title="3.算法验证"></a>3.算法验证</h2><p>​        写好线性反馈移位寄存器之后，就在主函数调用。用一个逻辑判断，去看哪一次移位反馈后，寄存器状态和初始一样，就打断循环，输出当前循环次数，即为周期。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000000000</span>):  </span><br><span class="line">    <span class="keyword">if</span> init == init_ <span class="keyword">and</span> i != <span class="number">0</span> :  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;第&#123;0&#125;次:&quot;</span>.<span class="built_in">format</span>(i),init_)  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;序列周期为:&quot;</span>,i)  </span><br><span class="line">        <span class="keyword">break</span>  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;第&#123;0&#125;次:&quot;</span>.<span class="built_in">format</span>(i),init_)  </span><br><span class="line">    lfsr(init_,tap)  </span><br></pre></td></tr></table></figure>
<p>​        在循环中，调用函数，等待一会儿，就可以看到输出了周期。<br><img src="https://cdn.jsdelivr.net/gh/crownz-sec/Blog_Source@master/img/20200115162255.png#pic_center"></p>
<p>​        在这里，生成序列的周期是65535，拿计算器算了下，正好是2的16次方减1，而我的多项式阶数就是16。也就是说，我所选择的特征多项式正好是一个本原多项式。验证了课上所学，特征多项式是本原多项式的LFSR对应周期为2的多项式阶数次幂减1。</p>
<h2 id="4-实现难点"><a href="#4-实现难点" class="headerlink" title="4.实现难点"></a>4.实现难点</h2><p>​        这个反馈移位寄存器的书写并没有什么困难，按照那个移位寄存器的图，再加上反馈函数就可以很快写出。难在去找一个15阶以上的本原多项式去验证生成序列的周期。</p>
<p>​        刚开始，我用了书上的32阶本原多项式，但序列周期实在太大，而且还不会用python的多线程来加快处理速度，40多亿条的序列，python单个处理实在太慢，跑不出来。然后，问其他同学要了一个16阶的多项式，测试一下，没想到正好是一个本原多项式，那也就正好验证周期为65535，结论正确。</p>
<h1 id="三、对称密码-DES算法"><a href="#三、对称密码-DES算法" class="headerlink" title="三、对称密码-DES算法"></a>三、对称密码-DES算法</h1><h2 id="1-简介-2"><a href="#1-简介-2" class="headerlink" title="1.简介"></a>1.简介</h2><p>​        数据加密标准(DES,Data Encryption Standard)是一个对称密码体制，1976年被美国联邦政府的国家标准局确定为联邦资料处理标准，随后在国际上广泛流传开来。</p>
<p>​        DES的加密和解密使用同一密钥，有效密钥的长度为56位。对数据进行加解密的单位为64位，明文和密文的长度相同。而且它使用Feistel结构，具有加解密相似特性。</p>
<h2 id="2-算法流程-1"><a href="#2-算法流程-1" class="headerlink" title="2.算法流程"></a>2.算法流程</h2><p>​        DES的整个操作可以分为三部分：</p>
<p>​        ①初始置换和逆初始置换</p>
<p>​        ②轮函数</p>
<p>​        ③密钥编排</p>
<p>​        整个DES的基本结构如下：<br><img src="https://cdn.jsdelivr.net/gh/crownz-sec/Blog_Source@master/img/20200115162552.png#pic_center"></p>
<h3 id="2-1初始置换和逆初始置换"><a href="#2-1初始置换和逆初始置换" class="headerlink" title="2.1初始置换和逆初始置换"></a>2.1初始置换和逆初始置换</h3><p>​        初始置换是在第一轮迭代之前进行的，目的是将原明文块的位进行换位。逆初始置换是初始置换的逆置换。数据块经过初始置换和逆初始置换后，可以恢复到原有的位置。初始置换和逆初始置换的置换表都是固定且公开的，这步操作主要目的是为了在硬件实现时，更容易的将明文和密文以字节的大小存放入DES芯片中。<br><img src="https://cdn.jsdelivr.net/gh/crownz-sec/Blog_Source@master/img/20200115162630.png#pic_center"></p>
<h3 id="2-2轮函数"><a href="#2-2轮函数" class="headerlink" title="2.2轮函数"></a>2.2轮函数</h3><p>​        DES的轮函数有四部分组成：扩展置换(E盒)、密钥加、非线性代换(S盒)和线性置换(P盒)。<br><img src="https://cdn.jsdelivr.net/gh/crownz-sec/Blog_Source@master/img/20200115162657.png#pic_center"><br>​        扩展置换，它将32位输入扩展为48位输出。扩展方法为：将48位输出按8行6列的次序排列，排列时，将输入位序号按32、1、2、…、31、32、1的次序依次排列，且上一行的最后两位依次在下一行的起始位置得到重用。<br><img src="https://cdn.jsdelivr.net/gh/crownz-sec/Blog_Source@master/img/20200115162722.png#pic_center"></p>
<p>​        密钥加层的运算就是把E盒扩展输出的48位数据与48位字密钥进行逐位异或运算，输出48位数据。</p>
<p>​        非线性代换，利用S盒将E盒扩展生成的48位数据又重新压缩为32位数据。S盒实质是一个查表运算，8个S盒分别对应8个非线性的代换表，每个S盒的输入均为6位，输出为4位。再查表前，要将输入的48位数据分为8组，每组6位，然后分别进入8个S盒，进行运算。</p>
<p>​        S盒具体的查表方法：设S盒的6位输入为b1、b2、b3、b4、b5、b6。将b1、b6位组合为2位的二进制数，其相应的十进制数对应表的行号；b2、b3、b4和b5构成4位的二进制数，其相应的十进制数对应表的列号。<br><img src="https://cdn.jsdelivr.net/gh/crownz-sec/Blog_Source@master/img/20200115162943.png#pic_center"></p>
<p>​        线性置换用来进行简单的位置置换，它按照给定的列表进行位置调换，不进行扩展和压缩。</p>
<p><img src="https://cdn.jsdelivr.net/gh/crownz-sec/Blog_Source@master/img/20200115163015.png#pic_center"></p>
<h3 id="2-3密钥编排"><a href="#2-3密钥编排" class="headerlink" title="2.3密钥编排"></a>2.3密钥编排</h3><p>​        DES的初始64位密钥通过置换选择PC-1，来得到有效的56位密钥。这56位密钥分为2个28位数据C0和D0。每轮生成字密钥的迭代中，Ci-1盒Di-1分别循环左移1位或2位，移位后的值作为下一轮的输入，同时，也作为置换选择PC-2的输入，通过置换选择PC-2产生一个48位的输入，即产生一个子密钥。<br><img src="https://cdn.jsdelivr.net/gh/crownz-sec/Blog_Source@master/img/20200115164644.png#pic_center">)</p>
<h2 id="3-算法实现-1"><a href="#3-算法实现-1" class="headerlink" title="3.算法实现"></a>3.算法实现</h2><h3 id="3-1初始置换和逆初始置换"><a href="#3-1初始置换和逆初始置换" class="headerlink" title="3.1初始置换和逆初始置换"></a>3.1初始置换和逆初始置换</h3><p>​        在实现初始置换和逆初始置换的时候，只需要把已知的置换表预先存到一个一维数组中，初始的64位明文分组以这个数组的中数字减1的值作为新的序号，来附加到返回结果后面。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始IP置换  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">IP</span>(<span class="params">init_str</span>) :</span>    </span><br><span class="line">    res = <span class="string">&quot;&quot;</span>  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> IP_Sub:  </span><br><span class="line">        res += init_str[i-<span class="number">1</span>]  </span><br><span class="line">    <span class="keyword">return</span> res  </span><br><span class="line"><span class="comment"># IP逆置换  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">IP_re</span>(<span class="params">final_str</span>) :</span>  </span><br><span class="line">    res = <span class="string">&quot;&quot;</span>  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> IP_re_Sub:  </span><br><span class="line">        res += final_str[i-<span class="number">1</span>]  </span><br><span class="line">    <span class="keyword">return</span> res </span><br></pre></td></tr></table></figure>
<h3 id="3-2-E盒扩展"><a href="#3-2-E盒扩展" class="headerlink" title="3.2 E盒扩展"></a>3.2 E盒扩展</h3><p>​        E盒扩展的实现方法跟上面初始置换的实现方法一样。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Expan</span>(<span class="params">bin_str</span>) :</span>  </span><br><span class="line">    res = <span class="string">&quot;&quot;</span>  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> E :  </span><br><span class="line">        res += bin_str[i-<span class="number">1</span>]  </span><br><span class="line">    <span class="keyword">return</span> res  </span><br></pre></td></tr></table></figure>
<h3 id="3-3-密钥加"><a href="#3-3-密钥加" class="headerlink" title="3.3 密钥加"></a>3.3 密钥加</h3><p>​        实现密钥加的时候，将E盒扩展的位和密钥的位，换为数字格式，就可以用数学符号异或，之后，根据异或结果，在返回结果后添加上字符类型的0或1。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Xor</span>(<span class="params"><span class="built_in">str</span>,key</span>) :</span>  </span><br><span class="line">    res = <span class="string">&quot;&quot;</span>  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(<span class="built_in">str</span>)) :  </span><br><span class="line">        xor_res = <span class="built_in">int</span>(<span class="built_in">str</span>[i],<span class="number">10</span>) ^ <span class="built_in">int</span>(key[i],<span class="number">10</span>)  </span><br><span class="line">        <span class="keyword">if</span> xor_res == <span class="number">1</span> :  </span><br><span class="line">            res += <span class="string">&#x27;1&#x27;</span>  </span><br><span class="line">        <span class="keyword">elif</span> xor_res == <span class="number">0</span> :  </span><br><span class="line">            res += <span class="string">&#x27;0&#x27;</span>  </span><br><span class="line">    <span class="keyword">return</span> res  </span><br></pre></td></tr></table></figure>
<h3 id="3-4-S盒代换"><a href="#3-4-S盒代换" class="headerlink" title="3.4 S盒代换"></a>3.4 S盒代换</h3><p>​        因为字符是二进制字符型的，在python中选择字符串中相应的字符后，可以直接用加号连接，之后再把相应行列号转为数字，在一位数组中查找即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Sub</span>(<span class="params">xor_str</span>) :</span>  </span><br><span class="line">    res = <span class="string">&quot;&quot;</span>  </span><br><span class="line">    count = <span class="number">0</span>     <span class="comment">#用来计数S盒，共8个  </span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(xor_str),<span class="number">6</span>) :  <span class="comment">#每6个分一组，循环8次  </span></span><br><span class="line">        now_str = xor_str[i:i+<span class="number">6</span>]    <span class="comment">#将第i个分组，切片处理  </span></span><br><span class="line">        row = <span class="built_in">int</span>(now_str[<span class="number">0</span>] + now_str[<span class="number">5</span>],<span class="number">2</span>) <span class="comment">#二进制转化为十进制  </span></span><br><span class="line">        col = <span class="built_in">int</span>(now_str[<span class="number">1</span>:<span class="number">5</span>],<span class="number">2</span>)  </span><br><span class="line">  </span><br><span class="line">        <span class="comment"># S盒的第count个表,row*16是因为用一维列表存入矩阵值  </span></span><br><span class="line">        num = <span class="built_in">bin</span>(S[count][row*<span class="number">16</span> + col])[<span class="number">2</span>:] </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">4</span>-<span class="built_in">len</span>(num)) :  <span class="comment">#利用bin输出有可能不是4位str</span></span><br><span class="line">            num = <span class="string">&#x27;0&#x27;</span> + num       <span class="comment">#类型的值，下面的循环加上字符0  </span></span><br><span class="line">        res += num  </span><br><span class="line">        count += <span class="number">1</span>  </span><br><span class="line">    <span class="keyword">return</span> res  </span><br></pre></td></tr></table></figure>
<h3 id="3-5-P盒置换"><a href="#3-5-P盒置换" class="headerlink" title="3.5 P盒置换"></a>3.5 P盒置换</h3><p>​        仍然是把一维数组中数字减一，来作为编号，调整移位。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">PSub</span>(<span class="params">sub_str</span>) :</span>  </span><br><span class="line">    res = <span class="string">&quot;&quot;</span>  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> P :  </span><br><span class="line">        res += sub_str[i-<span class="number">1</span>]  </span><br><span class="line">    <span class="keyword">return</span> res  </span><br></pre></td></tr></table></figure>
<h3 id="3-6子密钥生成"><a href="#3-6子密钥生成" class="headerlink" title="3.6子密钥生成"></a>3.6子密钥生成</h3><p>​        生成密钥的时候，PC-1和PC-2就是查表，循环移位的位数在移位数组Shift中，循环左移利用python字符串的序号和拼接特性就可以实现。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_key</span>(<span class="params">key</span>) :</span>  </span><br><span class="line">    key_list = []  </span><br><span class="line">    key_change1 = PC1(key)  <span class="comment">#PC-1置换</span></span><br><span class="line">    key_C0 = key_change1[<span class="number">0</span>:<span class="number">28</span>]  </span><br><span class="line">    key_D0 = key_change1[<span class="number">28</span>:]  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> Shift :  <span class="comment">#循环移位 生成子密钥</span></span><br><span class="line">        key_c = left_shift(key_C0,i)  </span><br><span class="line">        key_d = left_shift(key_D0,i)  </span><br><span class="line">        key_output = PC2(key_c + key_d)  <span class="comment">#PC-2置换</span></span><br><span class="line">        key_list.append(key_output)  </span><br><span class="line">    <span class="keyword">return</span> key_list</span><br></pre></td></tr></table></figure>

<h3 id="3-7单次加密过程"><a href="#3-7单次加密过程" class="headerlink" title="3.7单次加密过程"></a>3.7单次加密过程</h3><p>​        这里对64位明文分组进行加密处理，整个流程和上面的算法流程中一样，很规律，需要注意的是，在最后一轮输出的时候，左右两边并不交换位置。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt_one</span>(<span class="params">bin_plain,bin_key</span>):</span> <span class="comment">#64位二进制加密  </span></span><br><span class="line">    mes_ip_bin = IP(bin_plain)    <span class="comment">#初始IP置换  </span></span><br><span class="line">    key_list = gen_key(bin_key)  </span><br><span class="line">    mes_left = mes_ip_bin[<span class="number">0</span>:<span class="number">32</span>]  </span><br><span class="line">    mes_right = mes_ip_bin[<span class="number">32</span>:]  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">15</span>):  </span><br><span class="line">        mes_tmp = mes_right     <span class="comment">#暂存右边32位  </span></span><br><span class="line">        f_res = fac(mes_tmp,key_list[i])    <span class="comment">#轮函数处理  </span></span><br><span class="line">        mes_right = Xor(mes_left,f_res)     <span class="comment">#右边f后，与左边密钥加  </span></span><br><span class="line">        mes_left = mes_tmp  <span class="comment">#初始右边32位放左边  </span></span><br><span class="line">  </span><br><span class="line">    f_res = fac(mes_right,key_list[<span class="number">15</span>])  <span class="comment">#轮函数f</span></span><br><span class="line">    mes_fin_left = Xor(mes_left,f_res)  <span class="comment">#最后一轮不交换位置</span></span><br><span class="line">    mes_fin_right = mes_right  </span><br><span class="line">    bin_cipher = IP_re(mes_fin_left+mes_fin_right)  </span><br><span class="line">    <span class="keyword">return</span> bin_cipher       <span class="comment">#返回二进制  </span></span><br></pre></td></tr></table></figure>

<h3 id="3-8单次解密过程"><a href="#3-8单次解密过程" class="headerlink" title="3.8单次解密过程"></a>3.8单次解密过程</h3><p>​        DES的加解密具有一致性，实际中，加密器可用作解密器，所以在实现解密的时候，跟加密的流程一致，只是在调用密钥的时候，将密钥列表倒序使用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt_one</span>(<span class="params">bin_cipher,bin_key</span>):</span>  </span><br><span class="line">    cipher_ip_bin = IP(bin_cipher)  </span><br><span class="line">    key_list = gen_key(bin_key)  </span><br><span class="line">    lst = <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">16</span>)   <span class="comment">#循环15次  </span></span><br><span class="line">    cipher_left = cipher_ip_bin[<span class="number">0</span>:<span class="number">32</span>]  </span><br><span class="line">    cipher_right = cipher_ip_bin[<span class="number">32</span>:]  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> lst[::-<span class="number">1</span>]:   <span class="comment">#表示逆转列表调用  </span></span><br><span class="line">        mes_tmp = cipher_right  </span><br><span class="line">        f_result = fac(cipher_right,key_list[i])  </span><br><span class="line">        cipher_right = Xor(cipher_left,f_result)  </span><br><span class="line">        cipher_left = mes_tmp  </span><br><span class="line">      </span><br><span class="line">    f_result = fac(cipher_right,key_list[<span class="number">0</span>])  </span><br><span class="line">    mes_fin_left = Xor(cipher_left,f_result)  </span><br><span class="line">    mes_fin_right = cipher_right  </span><br><span class="line">    bin_plain = IP_re(mes_fin_left + mes_fin_right)  </span><br><span class="line">    <span class="keyword">return</span> bin_plain    <span class="comment">#返回二进制   </span></span><br></pre></td></tr></table></figure>
<p>​        以上是DES各个主要步骤的函数实现，在实际应用的时候，还需要各种辅助函数来处理数据。就像我们日常使用的数据，不全是二进制，那就要编写函数将其转换为二进制；字符转为二进制不足64位，又要将其补为64位，还要写使用单次加密过程，来进行众多数据的加密函数。</p>
<h2 id="4-算法验证-1"><a href="#4-算法验证-1" class="headerlink" title="4.算法验证"></a>4.算法验证</h2><p>​        将自己的DES算法加了一些交互之后，运行程序。<br><img src="https://cdn.jsdelivr.net/gh/crownz-sec/Blog_Source@master/img/20200115165544.png#pic_center"><br>​        选择加密，输入要加密的字符串为:i love china,密钥:cumt。加密后，将密文输出到了文件中，方便后面解密。<br><img src="https://cdn.jsdelivr.net/gh/crownz-sec/Blog_Source@master/img/20200115165623.png#pic_center"><br>​        再选择解密，输入密钥:cumt，即可获得之前的明文:i love cumt。<br><img src="https://cdn.jsdelivr.net/gh/crownz-sec/Blog_Source@master/img/20200115165704.png#pic_center"><br>​        加解密成功实现，且恢复了自己输入的明文，即验证了自己算法的正确性。</p>
<h2 id="5-算法分析"><a href="#5-算法分析" class="headerlink" title="5.算法分析"></a>5.算法分析</h2><p>​        自从DES诞生，针对DES的讨论和攻击就没有停止，安全性主要包括四个方面:互补性、弱密钥、迭代轮数和密钥长度。</p>
<h3 id="5-1互补性"><a href="#5-1互补性" class="headerlink" title="5.1互补性"></a>5.1互补性</h3><p>​        DES有补码的特性，明文和密钥都取补时，密文也取补。<br><img src="https://cdn.jsdelivr.net/gh/crownz-sec/Blog_Source@master/img/20200115165817.png#pic_center"><br>​        在选择明文攻击下，可以对明文的补用同一密钥加密，这样由DES互补性就可以得到密钥的补对明文的加密结果。当穷举搜索密钥时，若输出密文为正常明文加密结果，则加密密钥就是现在所用的密钥；若输出密文是明文用密钥补的加密结果，则加密密钥就是现在所用密钥的补。<br>​        利用DES的互补性，可以使穷举搜索的工作量由256将为255，减少了一半，能极大地加快破解速度。</p>
<h3 id="5-2弱密钥"><a href="#5-2弱密钥" class="headerlink" title="5.2弱密钥"></a>5.2弱密钥</h3><p>​        DES有四个弱密钥，使用它们作为子密钥，将使得DES加密两次后，数据仍为原来的数据，或者说是，加密和解密有同样的效果。<br><img src="https://cdn.jsdelivr.net/gh/crownz-sec/Blog_Source@master/img/20200115165915.png#pic_center"><br>​        还有12个半弱密钥，使用一个半弱密钥K1加密，相当于使用其对应的半弱密钥K2解密，会减少攻击工作量。<br><img src="https://cdn.jsdelivr.net/gh/crownz-sec/Blog_Source@master/img/20200115165947.png#pic_center"><br>​        因为弱密钥和半弱密钥的数量非常少，在实际使用时，可以检测事先检测一下密钥是否为弱密钥或半弱密钥，再使用，去避免不必要的风险。</p>
<h3 id="5-3迭代轮数"><a href="#5-3迭代轮数" class="headerlink" title="5.3迭代轮数"></a>5.3迭代轮数</h3><p>​        DES的迭代轮数为16轮，为什么是16轮呢？因为使用差分分析方法时，对于8轮迭代的DES，在个人计算机上只需要几分钟就可以破解。而当DES进行16轮迭代的时候，差分分析攻击就没有穷举攻击有效了。所以DES的迭代轮数不应当减少，过多又会降低效率，这才定为16轮迭代。</p>
<h3 id="5-4密钥长度"><a href="#5-4密钥长度" class="headerlink" title="5.4密钥长度"></a>5.4密钥长度</h3><p>​        在DES刚诞生的时候，56位的有效密钥就被认为是不安全的，因为它是从112位削减过来的。但即便这样，以当时的计算机处理能力想要穷举搜索256的密钥量，是非常困难的。1977年，Diffie和Hellman设想了一种机器可以在1μs之内完成一次加密，使平均搜索时间降到10个小时，但机器的造价在当时是2000万美元，很不切实际。</p>
<p>​        但随着计算机性能的不断提高，用穷举攻击来破解DES成为现实。1998年，一台25万美元的计算机在56小时内破解了DES，这个时间内，破译的密钥仍具有时效性，意味着DES已经不再安全。只得转向三重DES，来增大密钥长度，缓解密钥长度不足带来的安全问题。</p>
<h2 id="6-选择工具原因"><a href="#6-选择工具原因" class="headerlink" title="6.选择工具原因"></a>6.选择工具原因</h2><p>​        在这个算法实现中，python的字符串特性非常方便，像将明文分组分为两半、实现循环移位、二进制位置换都体现了这一点，所以选择python没有错。</p>
<h2 id="7-实现难点"><a href="#7-实现难点" class="headerlink" title="7.实现难点"></a>7.实现难点</h2><p>​        对自己来说，因为想实现的是字符的加解密，所以第一个困难就是将字符化为二进制，这里是更深刻的体会了一个字符占8位，不足还要补齐，不然后面解码要出错。</p>
<p>​        然后就是在解密的时候，处理的是二进制，不能讲加密结果简单的转为字符串，再将字符串复制过去，调用字符串转二进制函数，因为，密文每8位的二进制是很混乱的，并没有对应的编码，如果复制字符串，会不知道哪里是密文的终止处。所以，要么是密文就直接二进制不要动，复制解密的时候，不会错；要么是输出到文件中，等解密的时候，在从文件中读出。这里，我选择输出到文件中，这样密文转为字符串，也没有影响，因为文件算是闭合的，读取时，只会读取数据的部分，不会出现之前叙述的问题。</p>
<p>​        最后，就是S盒、E盒等等，不要弄错，当时的盒都是百度找的，结果运行不了。最后各种调试，才发现是PC-2盒错了，资料的查询一定要官方，可信度高一点 。</p>
<h1 id="四、非对称密码-RSA算法"><a href="#四、非对称密码-RSA算法" class="headerlink" title="四、非对称密码-RSA算法"></a>四、非对称密码-RSA算法</h1><h2 id="1-简介-3"><a href="#1-简介-3" class="headerlink" title="1.简介"></a>1.简介</h2><p>​        在Diffie和Hellman提出公钥密码体制的设想后，Merkle和Hellman首先共同提出MH背包公钥加密体制，随后Rivest、Shamir、Adleman联合提出RSA公钥加密体制。RSA虽晚于MH背包公钥加密体制，但它是第一个安全、实用的公钥加密算法，已成为国际标准。</p>
<p>​        RSA的基础是数论的欧拉定理，它的安全性依赖于大整数因子分解的困难性。且因为加解密次序可换，RSA公钥佳美体制既可用于加密，也可用于设计数字签名体制。</p>
<h2 id="2-算法流程-2"><a href="#2-算法流程-2" class="headerlink" title="2.算法流程"></a>2.算法流程</h2><p>​        RSA加密算法的操作可以分为三部分:密钥生成算法、加密算法和解密算法。</p>
<h3 id="2-1密钥生成"><a href="#2-1密钥生成" class="headerlink" title="2.1密钥生成"></a>2.1密钥生成</h3><p>​        (1)选择两个大素数 p, q ( p  ≠ q ，建议步骤(4)以后销毁) </p>
<p>​        (2)计算n = p×q，φ(n) = (p-1)×(q-1) </p>
<p>​        (3)选择整数e，使(φ(n), e) = 1，其中1&lt;e&lt;φ(n)</p>
<p>​        (4)计算d，使d = e<sup>-1</sup> mod φ(n)</p>
<p>​        得到公钥{e, n}和私钥{d}。</p>
<p>​        2.2加密</p>
<p>​        明文M &lt; n，密文C = M<sup>e</sup>(mod n)</p>
<p>​        2.3解密</p>
<p>​        密文C，明文M = C<sup>d</sup>(mod n)</p>
<h2 id="3-算法实现-2"><a href="#3-算法实现-2" class="headerlink" title="3.算法实现"></a>3.算法实现</h2><h3 id="3-1生成大奇数"><a href="#3-1生成大奇数" class="headerlink" title="3.1生成大奇数"></a>3.1生成大奇数</h3><p>​        因为素数没有规律，不能有规律地产生很多素数，只能是先产生一个数，然后再判断它是不是素数。这里是，先产生一个足够大的奇数(因为除了2其他素数都是奇数)，然后再通过素性检验来判断这个数是否是素数，不是的话，就要重新产生。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_bin</span>(<span class="params">num</span>):</span> <span class="comment">#num为希望产生伪素数的位数  </span></span><br><span class="line">    <span class="built_in">list</span> = []  </span><br><span class="line">    <span class="built_in">list</span>.append(<span class="string">&#x27;1&#x27;</span>)    <span class="comment">#最高位为1  </span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num-<span class="number">2</span>):  </span><br><span class="line">        c = random.choice([<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;1&#x27;</span>])  </span><br><span class="line">        <span class="built_in">list</span>.append(c)  </span><br><span class="line">    <span class="built_in">list</span>.append(<span class="string">&#x27;1&#x27;</span>)    <span class="comment">#最低位为1  </span></span><br><span class="line">    res = <span class="built_in">int</span>(<span class="string">&quot;&quot;</span>.join(<span class="built_in">list</span>),<span class="number">2</span>)  </span><br><span class="line">    <span class="keyword">return</span> res  </span><br></pre></td></tr></table></figure>

<h3 id="3-2快速幂"><a href="#3-2快速幂" class="headerlink" title="3.2快速幂"></a>3.2快速幂</h3><p>​        下面的素性检验需要用到快速计算模幂，这里就把它封装起来，方便后面调用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">X_n_mod_P</span>(<span class="params">x,n,p</span>):</span>  <span class="comment"># 计算x的n次方模p,快速计算模幂</span></span><br><span class="line">    res = <span class="number">1</span>  </span><br><span class="line">    n_bin = <span class="built_in">bin</span>(n)[<span class="number">2</span>:]  <span class="comment"># 幂次的二进制</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(n_bin)):  </span><br><span class="line">        res = res**<span class="number">2</span> % p </span><br><span class="line">        <span class="keyword">if</span> n_bin[i] == <span class="string">&#x27;1&#x27;</span>:  </span><br><span class="line">            res = res * x % p  </span><br><span class="line">    <span class="keyword">return</span> res  </span><br></pre></td></tr></table></figure>
<h3 id="3-3素性检验"><a href="#3-3素性检验" class="headerlink" title="3.3素性检验"></a>3.3素性检验</h3><p>​        素性检验分了两步，首先是条件宽松的费马小定理，通过这个检验之后，才是更为严格的Miller-Rabin检验。这两者的代码实现，都是参照具体的定理和公式，将其转化为代码。</p>
<p>​        费马小定理:若a是一个整数，p是一个指数，那么p|a<sup>p</sup>-a。 </p>
<p>​        Miller-Rabin算法:要检验n是否为素数，首先将n-1分解为2<sup>s</sup>d，每次测试前，随机选取一个介于[1, n - 1]的整数a，然后若对于所有的r ∈[0, s - 1]，若a<sup>d</sup> mod n ≠ -1，则n为合数，否则n有0.75的概率为素数。增加测试次数，其为素数的概率也就越高。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fermat_test</span>(<span class="params">a,n</span>):</span>  <span class="comment"># 如果n是一个素数，a是小于n的任意正整数， </span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:       <span class="comment"># 那么a的n次方与a模n同余  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span>  </span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">2</span>:  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span>  </span><br><span class="line">    res = X_n_mod_P(a,n-<span class="number">1</span>,n)  <span class="comment">#   以2为底  </span></span><br><span class="line">    <span class="keyword">return</span> res == <span class="number">1</span>  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MillerRabin</span>(<span class="params">n</span>):</span>  <span class="comment"># 二次探测,进一步判断n是否为素数  </span></span><br><span class="line">    a = random.randint(<span class="number">2</span>,n-<span class="number">2</span>)<span class="comment">#随机选择 2-n-2  </span></span><br><span class="line">    <span class="keyword">if</span> fermat_test(a,n) == <span class="number">1</span>:<span class="comment">#p经过判断，可能为素数  </span></span><br><span class="line">        d = n-<span class="number">1</span> <span class="comment">#初始的d  </span></span><br><span class="line">        <span class="built_in">sum</span> = <span class="number">0</span> <span class="comment">#d中因子2的次数  </span></span><br><span class="line">        <span class="keyword">while</span> (d%<span class="number">2</span>) == <span class="number">0</span>:  </span><br><span class="line">            <span class="built_in">sum</span> += <span class="number">1</span>  </span><br><span class="line">            d = d&gt;&gt;<span class="number">1</span>  </span><br><span class="line">        x=X_n_mod_P(a,d,n)  </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">sum</span>):  </span><br><span class="line">            new_x = X_n_mod_P(x,<span class="number">2</span>,n)  </span><br><span class="line">            <span class="keyword">if</span> new_x == <span class="number">1</span> <span class="keyword">and</span> x != <span class="number">1</span> <span class="keyword">and</span> x != n-<span class="number">1</span>:  </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span>  </span><br><span class="line">            x = new_x  </span><br><span class="line">        <span class="keyword">if</span> x != <span class="number">1</span>:  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span>  </span><br><span class="line">        <span class="keyword">else</span>:  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span>  </span><br></pre></td></tr></table></figure>
<h3 id="3-4产生大素数"><a href="#3-4产生大素数" class="headerlink" title="3.4产生大素数"></a>3.4产生大素数</h3><p>​        在这里是产生512位的大素数，在产生初始的大奇数之后，通过多次调用Miller-Rabin素性检测，来判断这附近的奇数是不是素数，如果是，就返回该数；如果不是，就重新产生，知道产生一个数通过测试。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_512</span>():</span>  </span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:  </span><br><span class="line">        d = gen_bin(<span class="number">512</span>)  </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">50</span>):<span class="comment"># 伪素数附近50个奇数都没有真素数 重新产生一个伪素数  </span></span><br><span class="line">            flag = testMillerRabin(d+<span class="number">2</span>*i,<span class="number">5</span>)<span class="comment"># 增加测试轮数，来提升精确度  </span></span><br><span class="line">            <span class="keyword">if</span> flag:  </span><br><span class="line">                b = d + <span class="number">2</span>*i<span class="comment">#这个数通过检验  </span></span><br><span class="line">                <span class="keyword">break</span>  </span><br><span class="line">            <span class="keyword">else</span>:  </span><br><span class="line">                <span class="keyword">continue</span>  </span><br><span class="line">        <span class="keyword">if</span> flag:  </span><br><span class="line">            <span class="keyword">return</span> b  </span><br><span class="line">        <span class="keyword">else</span>:  </span><br><span class="line">            <span class="keyword">continue</span>  </span><br></pre></td></tr></table></figure>
<h3 id="3-5求模逆"><a href="#3-5求模逆" class="headerlink" title="3.5求模逆"></a>3.5求模逆</h3><p>​        在RSA生成密钥的时候，需要使用模逆运算。这里利用辗转相除法的变形来求模逆，将相应定理转化为代码如下。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">invert</span>(<span class="params">e,phi</span>):</span>  <span class="comment"># 模逆存在的前提是两者互素  </span></span><br><span class="line">    a_list = []  </span><br><span class="line">    m = phi  </span><br><span class="line">    n = e  </span><br><span class="line">    tmp = m % n  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span>(tmp != <span class="number">0</span>):  </span><br><span class="line">        a = (m - tmp)/n  </span><br><span class="line">        a_list.append(a)  </span><br><span class="line">        m = n  </span><br><span class="line">        n = tmp  </span><br><span class="line">        tmp = m % n  </span><br><span class="line">    a_list.reverse()  </span><br><span class="line">    b_list = []  </span><br><span class="line">    b_list.append(<span class="number">1</span>)    <span class="comment">#倒数第二个式子,互素得到为1  </span></span><br><span class="line">    b_list.append(a_list[<span class="number">0</span>])  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(a_list)-<span class="number">1</span>):  </span><br><span class="line">        b = b_list[-<span class="number">1</span>] * a_list[i+<span class="number">1</span>] + b_list[-<span class="number">2</span>]  </span><br><span class="line">        b_list.append(b)  </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(a_list) % <span class="number">2</span> == <span class="number">0</span>:<span class="comment">#list数目为偶数  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(b_list[-<span class="number">1</span>])  </span><br><span class="line">    <span class="keyword">else</span>:                   <span class="comment">#list数目为奇数  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(phi-b_list[-<span class="number">1</span>])  </span><br></pre></td></tr></table></figure>
<p>​        这里好像出了点问题，后面把报告都交了，才发现我这个求模逆的算法出错了，当时演示验证的时候，我好像调用的是gmpy2的库，才没出错。emmm，要是有人看到这里，还请 不要参考这个代码。</p>
<h2 id="4-算法验证-2"><a href="#4-算法验证-2" class="headerlink" title="4.算法验证"></a>4.算法验证</h2><p>​        如果一段明文能经过RSA加密，在解密后，能恢复出明文，就验证了RSA算法的正确性。编写如下算法主流程。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Loading...&quot;</span>)  </span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:  </span><br><span class="line">    p = gen_512()  </span><br><span class="line">    q = gen_512()  </span><br><span class="line">    n = p*q  </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">len</span>(<span class="built_in">bin</span>(n)[<span class="number">2</span>:])) == <span class="number">1024</span>:  </span><br><span class="line">        <span class="keyword">break</span>  </span><br><span class="line">phi = (p-<span class="number">1</span>)*(q-<span class="number">1</span>)  </span><br><span class="line">e=<span class="number">65537</span>  </span><br><span class="line">d=invert(e,phi)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;d:&quot;</span>,d)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;e:&quot;</span>,e)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;n:&quot;</span>,n)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;---------&quot;</span>)  </span><br><span class="line">m=libnum.s2n(<span class="string">&quot;i love cumt!&quot;</span>)<span class="comment">#明文数字  </span></span><br><span class="line">c=X_n_mod_P(m,e,n)    <span class="comment">#密文  </span></span><br><span class="line">m=X_n_mod_P(c,d,n)    <span class="comment">#明文数字  </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;明文:&quot;</span>,libnum.n2s(m))  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>​        运行上面算法，可以看到，明文仍然为:i love cumt!，即验证算法正确。<br><img src="https://cdn.jsdelivr.net/gh/crownz-sec/Blog_Source@master/img/20200115173111.png#pic_center"></p>
<h2 id="5-算法分析-1"><a href="#5-算法分析-1" class="headerlink" title="5.算法分析"></a>5.算法分析</h2><p>​        针对RSA的攻击有很多种，主要是参数选择、使用不当造成的，下面就对这些进行讨论。</p>
<h3 id="5-1因子分解法"><a href="#5-1因子分解法" class="headerlink" title="5.1因子分解法"></a>5.1因子分解法</h3><p>​        SA密码体制的安全性主要依赖于大整数因数分解的难题，试图分解模数 n的素因子是攻击RSA最直接的方法。如果能够分解n，那么φ(n) = (p-1)×(q-1)就可以分解出来。分解方法有试除法、p-1因子分解法、p+1因子分解法、二次筛因子分解法、椭圆曲线因子分解法、数域筛因子分解法等。但由于因子分解的时间复杂性并没有降为多项式时间，因此，因子分解还是一个计算上的难题，只是在实际使用中，需要考虑使用较大的位数，以确保无法在短时间内被破解。 </p>
<h3 id="5-2共模攻击"><a href="#5-2共模攻击" class="headerlink" title="5.2共模攻击"></a>5.2共模攻击</h3><p>​        在实现RSA的时候，有时为了方便，在共享同一消息的时候，会让多个用户使用相同的模数n，但公、私钥对不同。而这种做法是不安全的。</p>
<p>​        设两个用户的公开密钥为e1和e2，且e1和e2互素，明文消息m，密文分别为c1≡m<sup>e1</sup>(mod n)，c2≡m<sup>e2</sup>(mod n)。攻击者截获c1和c2之后，用拓展欧几里得算法求出满足re1+se2=1的两个整数r和s，由此可得c1<sup>r</sup>c2<sup>s</sup>≡m<sup>re1</sup>m<sup>se2</sup>≡m<sup>re1+se2</sup>≡m(mod n)，即获取明文。</p>
<h3 id="5-3低加密指数攻击"><a href="#5-3低加密指数攻击" class="headerlink" title="5.3低加密指数攻击"></a>5.3低加密指数攻击</h3><p>​        有时为了增强加密的高效性，会使用较小的加密密钥e，但将消息发送给多个实体时，这样就会存在很大问题。</p>
<p>​        当e=3的时候，如果明文也较小，会使得明文的三次方仍然小于n，当将多个消息通过不同模数产生密文时，可以通过中国剩余定理来求出m<sup>3</sup>对多个模数乘积的取余结果，又m<sup>3</sup>小于模数乘积，对m<sup>3</sup>直接开立方，就可以得到结果。</p>
<h3 id="5-4循环攻击"><a href="#5-4循环攻击" class="headerlink" title="5.4循环攻击"></a>5.4循环攻击</h3><p>​        当攻击者截获密文之后，可以对密文进行循环加密，将每次加密结果和密文进行对比，如果有哪一次的加密结果和密文相同，说明上一次的加密结果即为明文。这种攻击只有在循环加密密文，再次得到原始密文的次数比较小的时候，才是可行的。为了抵抗这种攻击，应当通过p和q的选择，使得p-1和q-1都有较大的素因子。</p>
<p>​        为了防范这些攻击，首先应当使得密钥长度足够大，NIST建议，若保密期限超过2015年，则建议至少使用2048比特长密钥。同时，p和q的选取应当满足以下几点要求：</p>
<p>​        ①p和q的长度相差不能太大</p>
<p>​        ②p和q的差值不应该太小</p>
<p>​        ③p-1和q-1的公因数应尽可能小</p>
<p>​        ④p-1和q-1都应该有大的素数因子</p>
<h2 id="6-选择工具原因-1"><a href="#6-选择工具原因-1" class="headerlink" title="6.选择工具原因"></a>6.选择工具原因</h2><p>​        在这里，python的优势在于它语言的简洁性和描述性，通过近似英语的描述，就可以实现出多个数学公式和定理的代码形式。</p>
<h2 id="7-实现难点-1"><a href="#7-实现难点-1" class="headerlink" title="7.实现难点"></a>7.实现难点</h2><p>​        首先是找到可行的素性检测方法，需要搜索一番资料，然后就是对这些方法的代码实现，比较难一点。</p>
<h1 id="五、Hash函数-MD5算法"><a href="#五、Hash函数-MD5算法" class="headerlink" title="五、Hash函数-MD5算法"></a>五、Hash函数-MD5算法</h1><h2 id="1-简介-4"><a href="#1-简介-4" class="headerlink" title="1.简介"></a>1.简介</h2><p>​        Hash，一般翻译做散列、杂凑，或音译为哈希，是把任意长度的输入(又叫做预映射)通过散列算法变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是说，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来确定唯一的输入值。简单的说就是是将任意长度的输入变换为固定长度的输出的不可逆的单向密码体 制。</p>
<p>​        MD5(Message-Digest Algorithm,信息摘要算法)，是由美国著名密码学家Rivest设计的一种密码散列函数，可以将长度小于2<sup>64</sup>比特的消息，按512比特的分组单位进行处理，输出一个128比特的消息摘要。</p>
<h2 id="2-算法流程-3"><a href="#2-算法流程-3" class="headerlink" title="2.算法流程"></a>2.算法流程</h2><p>​        MD5算法的流程可以分为:附加填充位、初始化链接变量、分组处理和步函数。<br><img src="https://cdn.jsdelivr.net/gh/crownz-sec/Blog_Source@master/img/20200115173924.png#pic_center"></p>
<h3 id="2-1附加填充位"><a href="#2-1附加填充位" class="headerlink" title="2.1附加填充位"></a>2.1附加填充位</h3><p>​        首先需要对明文信息进行填充，使其位长度模512和448同余。因此，信息的位长度被扩展至512×N + 448。然后在这个结果后面附加一个以64位二进制表示的填充前信息长度。经过这两步的处理，现在的信息字节长度为512 × N + 448 + 64 = (N + 1) × 512，即长度恰好是512的整数倍。 </p>
<h3 id="2-2初始化链接变量"><a href="#2-2初始化链接变量" class="headerlink" title="2.2初始化链接变量"></a>2.2初始化链接变量</h3><p>​        使用4个32位的寄存器A，B，C，D存放4个固定的32位整型参数，<br>A:0x1234567,B:0x89ABCDEF,C:0xFEDCBA98,D:0x76543210。</p>
<h3 id="2-3分组处理"><a href="#2-3分组处理" class="headerlink" title="2.3分组处理"></a>2.3分组处理</h3><p>​        将填充好的信息进行分组，每组512位 ,共有N组。主循环有四轮，每轮循环包括16个步骤。每步的输入是4个32比特的链接变量和一个32比特的消息子分组，输出为32位值。经过4轮共64步之后，得到的4个寄存器值分别与输入链接变量进行模加，即得到此次分组处理的输出链接变量。<br><img src="https://cdn.jsdelivr.net/gh/crownz-sec/Blog_Source@master/img/20200115174150.png#pic_center"></p>
<h3 id="2-4步函数"><a href="#2-4步函数" class="headerlink" title="2.4步函数"></a>2.4步函数</h3><p>​        MD5每轮包含16步，每轮的步函数相同，即使用同一个非线性函数，而不同轮的步函数使用的非线性函数是不同的，即四轮使用4个不同的非线性函数。设X、Y、Z是3个32比特的输入变量，输出是一个32比特变量，则这4个非线性函数F、G、H和I定义为：</p>
<p>​        F(X,Y,Z)=(X&amp;Y)|((~X)&amp;Z)</p>
<p>​        G(X,Y,Z)=(X&amp;Z)|(Y&amp;(~Z))</p>
<p>​        H(X,Y,Z)=X^Y^Z</p>
<p>​        I(X,Y,Z)=Y^(X|(~Z))</p>
<p><img src="https://cdn.jsdelivr.net/gh/crownz-sec/Blog_Source@master/img/md5.png#pic_center"></p>
<h2 id="3-算法实现-3"><a href="#3-算法实现-3" class="headerlink" title="3.算法实现"></a>3.算法实现</h2><h3 id="3-1附加填充位"><a href="#3-1附加填充位" class="headerlink" title="3.1附加填充位"></a>3.1附加填充位</h3><p>​       下面这段话是在当初学习的时候所写，近期在复习密码学时想到了这个问题，看了其他人的博客，认为原先这个必须附加0x80的描述是不准确的。之前验证的时候，没有出错只是碰到了大多数附加填充位大于8bit的状况，如果验证例子够多，肯定会有出错的例子。</p>
<blockquote>
<p>​        对输入的消息先附加0x80，这一步不可少，之后再去判断模512是否跟448同余。需要注意的是，即便是消息长度刚好是模512和448同余，也要有附加填充位这个操作，这时就是填充512位，最高位为1，其余都为0，使填充后消息再模512和448同余，可以说是，附加0x80的优先级要高于判断同余。</p>
</blockquote>
<p>​       在找了很多博客之后，发现这一点都是很模糊，最后想到去找官方文档看看，这总不至于理解不清吧。这就在<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc1321">这里</a>看到了描述，截取填充的内容如下。看到最后描述说，填充总是必需的，最少1bit，最多512bit。所以，这个必须先附加0x80是有问题。如果人家就差1bit就能满足条件了，附加0x80(8bit)不就出错了吗。总的来说，之前写的附加填充位代码还是有问题的，应该先检查长度，决定要附加消息的位数，再去附加填充，就可以了。<del>代码也懒得改了</del>，如果有谁看到这里想应用，记得把下面那个代码逻辑改下，应该挺好弄，就几行。先判断差多少，然后去附加填充位数，使得之后的位数模512和448同余。</p>
<blockquote>
<p>3.1 Step 1. Append Padding Bits</p>
<p>The message is “padded” (extended) so that its length (in bits) is congruent to 448, modulo 512. That is, the message is extended so that it is just 64 bits shy of being a multiple of 512 bits long. Padding is always performed, even if the length of the message is  already congruent to 448, modulo 512.</p>
<p>Padding is performed as follows: a single “1” bit is appended to the message, and then “0” bits are appended so that the length in bits of the padded message becomes congruent to 448, modulo 512. In all, at least one bit and at most 512 bits are appended.</p>
</blockquote>
<p>​        在填充消息之后，还要注意大小端序的转换，这些数字在寄存器中是以小端序进行存储的，不然就会出错。为什么这样呢？因为MD5这个算法认为分组里面的数据都是小端序存储的，我们必须要把数据存储成它想要的小端序。更详细的话，参见这篇<a target="_blank" rel="noopener" href="https://blog.csdn.net/fullsail/article/details/8607567">文章</a>。那为什么MD5认为数据是小端序的呢，因为这是标准规定（RFC1321），Rivest设计之初就是这样考虑的，就像1+1=2这样的东西，记着就好了。</p>
<p>​        用下面这个图来理解一下，我们已知一个地址<code>0x11223344</code>，想要小端序存储，就要高字节高地址，低字节低地址，得到结果为<code>0x44332211</code>。同样，给出的初始链接变量中，<code>A=0x01234567</code>，小端序存储就为<code>0x67452301</code>，其他变量B、C、D也是如此。等MD5的变换完成之后，再把小端序转换回去即可。</p>
<p><img src="https://gitee.com/crownz/blog_image/raw/master/20200627161017.png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">append</span>(<span class="params">mes</span>):</span>                         <span class="comment">#封装起来用  </span></span><br><span class="line">    ascii_list = <span class="built_in">map</span>(<span class="built_in">hex</span>,<span class="built_in">map</span>(<span class="built_in">ord</span>,input_m))      <span class="comment"># 转换为asc码  </span></span><br><span class="line">    ascii_list = <span class="built_in">list</span>(ascii_list)  </span><br><span class="line">    msg_lenth = <span class="built_in">len</span>(ascii_list)*<span class="number">8</span>  </span><br><span class="line">    <span class="comment">#对每一个输入先添加一个&#x27;0x80&#x27;，即&#x27;10000000&#x27;  </span></span><br><span class="line">    ascii_list.append(<span class="string">&#x27;0x80&#x27;</span>)  </span><br><span class="line">    <span class="comment">#补充0  </span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">len</span>(ascii_list)*<span class="number">8</span>+<span class="number">64</span>)%<span class="number">512</span> != <span class="number">0</span>:  </span><br><span class="line">        ascii_list.append(<span class="string">&#x27;0x00&#x27;</span>)  </span><br><span class="line">    <span class="comment">#最后64位存放消息长度，长度存放顺序是低位在前。  </span></span><br><span class="line">    msg_lenth_0x = <span class="built_in">hex</span>(msg_lenth)[<span class="number">2</span>:]  </span><br><span class="line">    msg_lenth_0x = <span class="string">&#x27;0x&#x27;</span> + msg_lenth_0x.rjust(<span class="number">16</span>,<span class="string">&#x27;0&#x27;</span>)  </span><br><span class="line">    msg_lenth_0x_big_order = reverse_hex(msg_lenth_0x)[<span class="number">2</span>:]      <span class="comment"># 反转  </span></span><br><span class="line">    msg_lenth_0x_list = []  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(msg_lenth_0x_big_order),<span class="number">2</span>):  </span><br><span class="line">        msg_lenth_0x_list.append(<span class="string">&#x27;0x&#x27;</span>+ msg_lenth_0x_big_order[i:i+<span class="number">2</span>])       </span><br><span class="line">    <span class="keyword">return</span> ascii_list.extend(msg_lenth_0x_list)  </span><br></pre></td></tr></table></figure>
<h3 id="3-2分组处理及步函数"><a href="#3-2分组处理及步函数" class="headerlink" title="3.2分组处理及步函数"></a>3.2分组处理及步函数</h3><p>​        将链接变量初始化后，存到fun_list，所用的各种非线性逻辑函数预先写好，在函数中用参数f调用，参数m是每轮运算所需要的消息分组(也要注意大小端序的转换)，参数shi是每次循环移位的位数，根据算法的要求预先定义到一个元组中，方便使用。算法的整体流程和图5.3的流程一样，只不过要多次循环处理。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span>(<span class="params">fun_list,f,m,shi</span>):</span><span class="comment">#参数为初始化链接变量 每轮用到的F G H I 生成的M[]，</span></span><br><span class="line">    count = <span class="number">0</span>  		    <span class="comment">#以及循环左移的位数。该函数用来完成一轮运算，共16步  </span></span><br><span class="line">    <span class="keyword">global</span> Ti_count      <span class="comment">#全局变量，T(i)从1到64循环  </span></span><br><span class="line">    <span class="keyword">while</span> count&lt;<span class="number">16</span>:  </span><br><span class="line">        <span class="comment"># A+轮函数处理+M[i]+T[i]  </span></span><br><span class="line">        xx = <span class="built_in">int</span>(fun_list[<span class="number">0</span>],<span class="number">16</span>)+f(<span class="built_in">int</span>(fun_list[<span class="number">1</span>],<span class="number">16</span>),<span class="built_in">int</span>(fun_list[<span class="number">2</span>],<span class="number">16</span>),<span class="built_in">int</span>(fun_list[<span class="number">3</span>],<span class="number">16</span>))+<span class="built_in">int</span>(m[count],<span class="number">16</span>)+T(Ti_count)  </span><br><span class="line">        xx = xx&amp;<span class="number">0xffffffff</span>  </span><br><span class="line">        <span class="comment"># 循环左移  </span></span><br><span class="line">        ll = L(xx,shi[count])  </span><br><span class="line">        fun_list[<span class="number">0</span>] = <span class="built_in">hex</span>((<span class="built_in">int</span>(fun_list[<span class="number">1</span>],<span class="number">16</span>) + ll)&amp;(<span class="number">0xffffffff</span>))  </span><br><span class="line">        <span class="comment"># ABCD -&gt; DABC  </span></span><br><span class="line">        fun_list = shift(fun_list)  </span><br><span class="line">        count += <span class="number">1</span>  </span><br><span class="line">        Ti_count += <span class="number">1</span>  </span><br><span class="line">    <span class="keyword">return</span> fun_list  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="3-3输出结果"><a href="#3-3输出结果" class="headerlink" title="3.3输出结果"></a>3.3输出结果</h3><p>​        将循环处理64步之后的4个输出和4个初始化链接变量分别相加后，存到一个列表中，在函数中 用f_list调用，将字符串进行大小端序转换，再连接，即输出MD5加密值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_result</span>(<span class="params">f_list</span>):</span>  </span><br><span class="line">    result = <span class="string">&#x27;&#x27;</span>  </span><br><span class="line">    f_list1 = [<span class="number">0</span>]*<span class="number">4</span>  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> f_list:  </span><br><span class="line">        f_list1[f_list.index(i)] = reverse_hex(i)[<span class="number">2</span>:]  </span><br><span class="line">        result = result + f_list1[f_list.index(i)]  </span><br><span class="line">    <span class="keyword">return</span> result  </span><br></pre></td></tr></table></figure>
<p>其他更详细的代码没有单独拿出来列举，具体可以参见github，博客最后附有链接。</p>
<h2 id="4-算法验证-3"><a href="#4-算法验证-3" class="headerlink" title="4.算法验证"></a>4.算法验证</h2><p>​        将算法整体实现之后，运行，输入要进行MD5加密的消息，这里为书上的例子:iscbupt，之后输出MD5加密值，跟书上相比对，除了这里字母是小写的之外，其他都跟书上一样。这里输出小写是因为python计算16进制是按小写来的，因为我之前存入初始链接变量是大写，它也按小写来处理，输出也是小写的，但它所代表的意思都没有变，所以这也没错。<br><img src="https://cdn.jsdelivr.net/gh/crownz-sec/Blog_Source@master/img/20200115174345.png#pic_center"></p>
<h2 id="5-算法分析-2"><a href="#5-算法分析-2" class="headerlink" title="5.算法分析"></a>5.算法分析</h2><p>​        MD5具有Hash函数的所有特性。</p>
<p>​        ①压缩性。无论输入的明文多长，计算出来的MD5值长度固定为128位。 </p>
<p>​        ②易计算性。由原数据容易计算出MD5值 。</p>
<p>​        ③抗碰撞性。知道明文和MD5值，很难找到相同MD5值相同的明文。 </p>
<p>​        ④抗修改性。即便修改一个字节，计算出来的MD5值也会存在极大差异 </p>
<p>​        MD5是在MD4基础上发展而来的，虽然比MD4稍慢，但更安全，实现了更快的雪崩效应，在实际应用中更受欢迎。</p>
<p>​        散列函数的安全性主要体现在其良好的单向性和对碰撞的有效避免。由于散列变换是一种压缩变换，输入和输出长度相差极大啊，很难通过输出来确定 输入。但是，散列函数经常被用于数据改动检测，如果一个合法消息和一个非法消息能够碰撞，攻击就可以用合法消息生成散列值，再以非法消息作为该散列值的对应消息进行欺骗，且是他人无法识别。所以，对于Hash函数的攻击，攻击者的主要目标不是恢复原始明文，而是用相同散列值的非法消息来替代合法消息进行伪造和欺骗。</p>
<p>​        对于MD5的碰撞研究，王小云教授做出了突破性的贡献，她的研究成果可以概括为：对于给定的M1，可以比较快速地找到M2，使得H(M1)=H(M2)。在2004年发表的论文中，她在IBM P690上用了一个小时左右就找了这样的一个碰撞，放到现在的计算机上面，这个时间会更短。所以，如果是要求高度保密的场所，比如说军工之类，MD5已经不安全了，应更换为更安全的Hash算法；但对于民用来说，一般没有人有能承受那么大计算量的设备，在一些不重要的认证上面仍可使用。</p>
<h2 id="6-选择工具原因-2"><a href="#6-选择工具原因-2" class="headerlink" title="6.选择工具原因"></a>6.选择工具原因</h2><p>​        使用python可以直观地描述出整个算法的流程，而且在大小端序的转换这里，利用它字符串的拼接特性，也可以较为容易地实现。</p>
<h2 id="7-实现难点-2"><a href="#7-实现难点-2" class="headerlink" title="7.实现难点"></a>7.实现难点</h2><p>​        下面所写的难点仍是之前写报告所写的，之前附加填充的理解错了，这里的实现难点自然也描述错了，实现难点就是理解这个流程，再用代码表述，还有大小端序的问题。</p>
<blockquote>
<p>​        对首先是附加长度，不知道附加0x80是必须的，不管它消息长度是不是模512和448同余，必须是先附加个0x80，之后再判断同余，再填充0。</p>
<p>​        还有一点是大小端序的转换，刚开始并不知道要进行转换，知道后，刚开始也只是对初始化链接变量进行大小端序转换了，这样还是不能得到正确结果。多次尝试之后，又去看别人所写，才知道知道每个消息分组的内容也要进行大小端序的转换。在将大小端序调整好以后，才是能正确的输出结果。</p>
</blockquote>
<h1 id="六、综合实验"><a href="#六、综合实验" class="headerlink" title="六、综合实验"></a>六、综合实验</h1><h2 id="1-简介-5"><a href="#1-简介-5" class="headerlink" title="1.简介"></a>1.简介</h2><p>​        现在，Alice想通过公共信道给Bob传输一份秘密文件（文件非常大）。又知道，很多人和机构想得到这份文件。需要设计一个通信模型，来保证文件的机密性和完整性。</p>
<h2 id="2-算法流程-4"><a href="#2-算法流程-4" class="headerlink" title="2.算法流程"></a>2.算法流程</h2><p>​        我设想算法模型分为三步，分别为身份认证、加密文件和对称密钥、解密对称密钥和文件。</p>
<p>​        现在很多人想要得到这份文件，那么，可能会有很多人在假冒Bob的身份，来请求得到这个文件，需要对Bob身份进行验证；也有可能是很多人得不到文件，就假冒Alice的身份，想要给Bob发送文件，如果有人发送恶意文件给Bob，Bob发现不是想要的文件，但这个文件给Bob电脑安装了后门，等他接受了正确的文件，就存在泄漏的风险，所以需要对Alice身份进行验证。</p>
<p>​        双向身份验证通过后，就可以收发数据，要发送的文件非常大，就采用对称加密算法，因为这个算法相较于非对称算法速度快。这里让通过公共信道进行传输，Bob和Alice不可能在公共信道交换密钥，则对称密钥也需要加密。那就使用非对称算法来对密钥加密，处理的密钥长度不算长，速度没有显著降低，而且是采用两种加密方法，在一定程度上可以增大攻击者的破解难度。加密完成后，就可以通过公共信道传输数据。</p>
<p>​        但Bob接收到加密消息后，先通过非对称算法的私钥计算出对称密钥，然后用对称密钥，就可以解密出明文。</p>
<h2 id="3-算法实现-4"><a href="#3-算法实现-4" class="headerlink" title="3.算法实现"></a>3.算法实现</h2><p>​        首先说明，整个算法的代码实现是利用python的socket编程来写的。Alice作为客户端，Bob作为服务端，方便说明。</p>
<h3 id="3-1身份认证"><a href="#3-1身份认证" class="headerlink" title="3.1身份认证"></a>3.1身份认证</h3><p>​        因为Bob是要接受数据 ，这里Bob作为服务端，被动地等待连接。当Alice连上后，就送出自己的身份hash，等待Bob验证。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;等待bob验证自身身份...&quot;</span>)  <span class="comment">#送出自己身份hash  </span></span><br><span class="line">hash_name = <span class="built_in">bytes</span>(Md5(name),<span class="string">&quot;utf-8&quot;</span>)  </span><br><span class="line">client.send(hash_name)  </span><br></pre></td></tr></table></figure>
<p>​        当Bob收到Alice发送的身份信息之后，就会通过Hash函数的比对，来验证是否通过验证，若通过验证，就会返回通过验证，并同时输送自己身份信息给Alice。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;验证alice身份...&quot;</span>)  </span><br><span class="line">a = <span class="built_in">input</span>()  </span><br><span class="line">hash_name = con.recv(<span class="number">512</span>).decode()  </span><br><span class="line"><span class="keyword">if</span> hash_name == Md5(<span class="string">&quot;alice&quot;</span>):  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;验证通过！&quot;</span>)  </span><br><span class="line">    con.send(<span class="built_in">bytes</span>(<span class="string">&quot;您通过了验证!&quot;</span>,<span class="string">&quot;utf-8&quot;</span>))  </span><br><span class="line"><span class="keyword">else</span>:  </span><br><span class="line">    <span class="built_in">print</span>(hash_name,Md5(<span class="string">&quot;alice&quot;</span>))  </span><br><span class="line">    exit(<span class="string">&quot;验证错误！&quot;</span>) </span><br></pre></td></tr></table></figure>
<p>​        Alice收到验证通过和Bob的身份信息，就会开始比对Bob的身份Hash，如果通过验证，Alice就可以继续下面的传输。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(client.recv(<span class="number">1024</span>).decode())  </span><br><span class="line"><span class="comment">#接收bob身份hash并验证  </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;验证bob身份...&quot;</span>,end=<span class="string">&quot;&quot;</span>)  </span><br><span class="line">a=<span class="built_in">input</span>()  </span><br><span class="line">hash_name = client.recv(<span class="number">1024</span>).decode()  </span><br><span class="line">client.send(<span class="string">b&#x27;1&#x27;</span>)  </span><br><span class="line"><span class="keyword">if</span> hash_name == Md5(<span class="string">&quot;bob&quot;</span>):  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;验证通过!&quot;</span>)  </span><br><span class="line"><span class="keyword">else</span>:  </span><br><span class="line">    <span class="built_in">print</span>(hash_name,Md5(<span class="string">&quot;bob&quot;</span>))  </span><br><span class="line">    exit(<span class="string">&quot;验证错误!&quot;</span>)  </span><br></pre></td></tr></table></figure>
<h3 id="3-2加密文件和对称密钥"><a href="#3-2加密文件和对称密钥" class="headerlink" title="3.2加密文件和对称密钥"></a>3.2加密文件和对称密钥</h3><p>​        当验证通过以后，Bob送出自己的公钥及Hash，防止他人篡改。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">con.send(<span class="built_in">bytes</span>(<span class="built_in">str</span>(e),<span class="string">&quot;utf-8&quot;</span>))  <span class="comment">#送出公钥及相应hash  </span></span><br><span class="line">con.recv(<span class="number">1024</span>)  </span><br><span class="line">hash_e = Md5(<span class="built_in">str</span>(e))  </span><br><span class="line">con.send(<span class="built_in">bytes</span>(hash_e,<span class="string">&quot;utf-8&quot;</span>)) </span><br></pre></td></tr></table></figure>
<p>​        当Alice收到公钥和Hash之后，先验证Hash正确性，通过之后 ，继续向下进行。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">e = <span class="built_in">int</span>(client.recv(<span class="number">1024</span>))  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;获取公钥:&quot;</span>, e)  </span><br><span class="line">client.send(<span class="string">b&#x27;1&#x27;</span>)  </span><br><span class="line">hash_e = client.recv(<span class="number">1024</span>).decode()  </span><br><span class="line"><span class="keyword">if</span> hash_e == Md5(<span class="built_in">str</span>(e)):  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;公钥正确!\n开始传输数据:&quot;</span>)  </span><br><span class="line"><span class="keyword">else</span>:  </span><br><span class="line">    exit(<span class="string">&quot;公钥错误!&quot;</span>)  </span><br></pre></td></tr></table></figure>
<p>​        公钥无误，可以开始加密数据。先调用对称密钥生成算法，随机生成一个对称密钥，这里用的是DES算法。有了密钥之后，调用DES加密算法进行加密文件。加密文件之后，再将对称密钥用RSA算法加密。加密完成之后，就将加密密钥和密文传输过去。要注意的是，在传输密文之前，还要传输密文的长度，方便Bob进行解密。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">bin_key = gen_key()         <span class="comment">#生成对称密钥  </span></span><br><span class="line">int_key = <span class="built_in">int</span>(bin_key,<span class="number">2</span>)      </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;产生对称密钥:&quot;</span>,int_key)  </span><br><span class="line">  </span><br><span class="line">plain = read_out_file()<span class="comment">#明文  </span></span><br><span class="line">bin_cipher = des_encrypt(bin_key, plain)<span class="comment">#二进制加密值  </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;加密明文中...&quot;</span>)  </span><br><span class="line">  </span><br><span class="line">cipher_key = X_n_mod_P(int_key, e, n)  </span><br><span class="line">plain_key = X_n_mod_P(cipher_key, d,n)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;加密对称密钥...&quot;</span>)  </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;传输密钥中...&quot;</span>)  <span class="comment">#传输密钥  </span></span><br><span class="line">client.sendall(<span class="built_in">bytes</span>(<span class="built_in">str</span>(int_key),<span class="string">&quot;utf-8&quot;</span>))  </span><br><span class="line">  </span><br><span class="line">client.recv(<span class="number">512</span>)  <span class="comment">#防止前后数据包的粘连</span></span><br><span class="line">  </span><br><span class="line">length = <span class="built_in">str</span>(<span class="built_in">len</span>(bin_cipher))  <span class="comment">#传输密文大小  </span></span><br><span class="line">length = <span class="built_in">bytes</span>(length,<span class="string">&quot;utf-8&quot;</span>)  </span><br><span class="line">client.send(length)  </span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;传输密文中...&quot;</span>)  <span class="comment">#传输密文  </span></span><br><span class="line">client.sendall(<span class="built_in">bytes</span>(<span class="built_in">str</span>(bin_cipher),<span class="string">&quot;utf-8&quot;</span>))  </span><br></pre></td></tr></table></figure>
<h3 id="3-3解密对称密钥和文件"><a href="#3-3解密对称密钥和文件" class="headerlink" title="3.3解密对称密钥和文件"></a>3.3解密对称密钥和文件</h3><p>​        Bob先接收密钥和密文，然后对密钥解密。得到对称之后，对密文进行解密，就可以得到明文。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">buffer = []  <span class="comment">#接收密钥  </span></span><br><span class="line">data = con.recv(<span class="number">1024</span>)  </span><br><span class="line">data = data.decode()<span class="comment">#str  </span></span><br><span class="line">int_key = <span class="built_in">int</span>(data)  </span><br><span class="line"><span class="built_in">print</span>(int_key)  </span><br><span class="line">  </span><br><span class="line">con.send(<span class="string">b&#x27;1&#x27;</span>)  <span class="comment">#防止前后数据包的粘连</span></span><br><span class="line">  </span><br><span class="line">length = con.recv(<span class="number">1024</span>)  <span class="comment">#接收密文长度  </span></span><br><span class="line">length = <span class="built_in">int</span>(length.decode())  </span><br><span class="line">  </span><br><span class="line">buffer = []  <span class="comment">#接收密文  </span></span><br><span class="line">size = <span class="number">0</span>  </span><br><span class="line"><span class="keyword">while</span> size &lt; length:  </span><br><span class="line">    dat = con.recv(<span class="number">1024</span>)      <span class="comment"># 每次最多接收1k字节</span></span><br><span class="line">    size += <span class="built_in">len</span>(dat.decode())  </span><br><span class="line">    buffer.append(dat)  </span><br><span class="line">data = <span class="string">b&#x27;&#x27;</span>.join(buffer)  </span><br><span class="line">bin_cipher = data.decode()<span class="comment">#接受信息  </span></span><br><span class="line"><span class="built_in">print</span>(bin_cipher)  </span><br><span class="line"> </span><br><span class="line">int_key = x_k_mod_n(int_key,d,n)  <span class="comment">#解密密钥 </span></span><br><span class="line">cipher = libnum.b2s(bin_cipher)  <span class="comment">#还原明文  </span></span><br><span class="line">bin_key = <span class="built_in">bin</span>(int_key)[<span class="number">2</span>:]  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;解密传输内容:&quot;</span>)  </span><br><span class="line"><span class="built_in">print</span>(libnum.b2s(des_decrypt(bin_key, cipher))) </span><br></pre></td></tr></table></figure>
<h2 id="4-算法验证-4"><a href="#4-算法验证-4" class="headerlink" title="4.算法验证"></a>4.算法验证</h2><h3 id="4-1身份认证"><a href="#4-1身份认证" class="headerlink" title="4.1身份认证"></a>4.1身份认证</h3><p>​        先运行Bob服务端，再运行Alice客户端，看到双方的验证都通过了。<br><img src="https://cdn.jsdelivr.net/gh/crownz-sec/Blog_Source@master/img/20200115175812.png#pic_center"><br><img src="https://cdn.jsdelivr.net/gh/crownz-sec/Blog_Source@master/img/20200115175838.png#pic_center"></p>
<h3 id="4-2加密文件和对称密钥"><a href="#4-2加密文件和对称密钥" class="headerlink" title="4.2加密文件和对称密钥"></a>4.2加密文件和对称密钥</h3><p>​        当验证通过以后，Alice就获取公钥并验证。通过之后，开始产生对称密钥并加密明文，明文加密完之后，就对对称密钥加密，加密以后。传输加密的密钥和密文。<br><img src="https://cdn.jsdelivr.net/gh/crownz-sec/Blog_Source@master/img/20200115175918.png#pic_center"></p>
<h3 id="4-3解密对称密钥和文件"><a href="#4-3解密对称密钥和文件" class="headerlink" title="4.3解密对称密钥和文件"></a>4.3解密对称密钥和文件</h3><p>​        Bob收到加密密钥和文件以后，对密钥解密，再对文件解密就得到了完整文件。这里的文件内容和自己本地一样，可以认为算法在传输数据上没有错误。<br><img src="https://cdn.jsdelivr.net/gh/crownz-sec/Blog_Source@master/img/20200115175958.png#pic_center"></p>
<h2 id="5-算法分析-3"><a href="#5-算法分析-3" class="headerlink" title="5.算法分析"></a>5.算法分析</h2><p>​        这个模型综合运用了之前的DES算法、RSA算法和MD5算法，是一个综合的算法。相较于单独运用每一种算法，这个算法更具安全性，能实现身份认证、完整性验证。</p>
<p>​        但是就再分析安全性，发现还是有些不足，因为这里采用了DES加密，在整个加密系统中，可以认为它安全性取决于最容易被破解的算法，在这里就是DES算法。因为随着相关研究的发表和计算机能力的提升，DES已经不再是牢不可破的，如果攻击者有这种能力，完全可以直接不管这个算法的其他部分。对密文截取以后，直接穷举攻击，就能得到文件内容。所以，在设计安全算法时，要考虑各个部分的安全性，不能顾此失彼。如果想要对这个算法进行改进，可以将对成加密算法换为AES算法或者IDEA算法，因为这两个算法，就目前来说，都没有明显有效的破解方法。</p>
<h2 id="6-选择工具原因-3"><a href="#6-选择工具原因-3" class="headerlink" title="6.选择工具原因"></a>6.选择工具原因</h2><p>​        python有额外写好的socket编程模块可以使用，在这里实现交互演示的时候更加方便。</p>
<h2 id="7-实现难点-3"><a href="#7-实现难点-3" class="headerlink" title="7.实现难点"></a>7.实现难点</h2><p>​        这个实验模型主题框架就是老师上课所讲，调用的算法也都是前面自己写过的，只不过，有些是自己又回去把它们给封装成函数在这里调用，并没有算法上的困难性。关键是socket编程，这一块是完全不会的，在实际做的时候，在多个数据包的粘连、数据编码和文件传输这方面，有很大问题，不会就去问同学和百度了，代码写得比较冗余，但总归算是能做出来。</p>
<blockquote>
<p>GitHub:<a target="_blank" rel="noopener" href="https://github.com/crownz-sec/Cryptography-course-design">https://github.com/crownz-sec/Cryptography-course-design</a></p>
</blockquote>

  </div>
</article>

    <div class="blog-post-comments">
        <div id="disqus_thread">
            <noscript>Please enable JavaScript to view the comments.</noscript>
        </div>
    </div>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81-%E7%BB%B4%E5%90%89%E5%B0%BC%E4%BA%9A%E5%AF%86%E7%A0%81"><span class="toc-number">1.</span> <span class="toc-text">一、古典密码-维吉尼亚密码</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%AE%80%E4%BB%8B"><span class="toc-number">1.1.</span> <span class="toc-text">1.简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B"><span class="toc-number">1.2.</span> <span class="toc-text">2.算法流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.3.</span> <span class="toc-text">3.算法实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1%E6%98%8E%E6%96%87%E9%A2%84%E5%A4%84%E7%90%86"><span class="toc-number">1.3.1.</span> <span class="toc-text">3.1明文预处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2%E5%AF%86%E9%92%A5%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E4%B8%BA%E6%95%B0%E5%AD%97%E5%88%97%E8%A1%A8"><span class="toc-number">1.3.2.</span> <span class="toc-text">3.2密钥字符串转为数字列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3%E5%8A%A0%E5%AF%86%E8%BF%87%E7%A8%8B"><span class="toc-number">1.3.3.</span> <span class="toc-text">3.3加密过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4%E8%A7%A3%E5%AF%86%E8%BF%87%E7%A8%8B"><span class="toc-number">1.3.4.</span> <span class="toc-text">3.4解密过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%AE%97%E6%B3%95%E9%AA%8C%E8%AF%81"><span class="toc-number">1.4.</span> <span class="toc-text">4.算法验证</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E7%AE%97%E6%B3%95%E7%A0%B4%E8%A7%A3"><span class="toc-number">1.5.</span> <span class="toc-text">5.算法破解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1%E7%A1%AE%E5%AE%9A%E5%AF%86%E9%92%A5%E9%95%BF%E5%BA%A6"><span class="toc-number">1.5.1.</span> <span class="toc-text">5.1确定密钥长度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2%E7%A1%AE%E5%AE%9A%E5%AF%86%E9%92%A5"><span class="toc-number">1.5.2.</span> <span class="toc-text">5.2确定密钥</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3%E6%81%A2%E5%A4%8D%E6%98%8E%E6%96%87%E5%B9%B6%E9%AA%8C%E8%AF%81"><span class="toc-number">1.5.3.</span> <span class="toc-text">5.3恢复明文并验证</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-number">1.6.</span> <span class="toc-text">6.算法分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E9%80%89%E6%8B%A9%E5%B7%A5%E5%85%B7%E5%8E%9F%E5%9B%A0"><span class="toc-number">1.7.</span> <span class="toc-text">7.选择工具原因</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E5%AE%9E%E7%8E%B0%E9%9A%BE%E7%82%B9"><span class="toc-number">1.8.</span> <span class="toc-text">8.实现难点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%BA%8F%E5%88%97%E5%AF%86%E7%A0%81-%E7%BA%BF%E6%80%A7%E5%8F%8D%E9%A6%88%E7%A7%BB%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">2.</span> <span class="toc-text">二、序列密码-线性反馈移位寄存器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%AE%80%E4%BB%8B-1"><span class="toc-number">2.1.</span> <span class="toc-text">1.简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.2.</span> <span class="toc-text">2.算法实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1%E9%80%89%E5%AE%9A%E5%88%9D%E5%A7%8B%E5%BA%8F%E5%88%97%E5%92%8C%E7%89%B9%E5%BE%81%E5%A4%9A%E9%A1%B9%E5%BC%8F"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.1选定初始序列和特征多项式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2%E7%BA%BF%E6%80%A7%E5%8F%8D%E9%A6%88%E7%A7%BB%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.2线性反馈移位寄存器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%AE%97%E6%B3%95%E9%AA%8C%E8%AF%81"><span class="toc-number">2.3.</span> <span class="toc-text">3.算法验证</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%AE%9E%E7%8E%B0%E9%9A%BE%E7%82%B9"><span class="toc-number">2.4.</span> <span class="toc-text">4.实现难点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81-DES%E7%AE%97%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">三、对称密码-DES算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%AE%80%E4%BB%8B-2"><span class="toc-number">3.1.</span> <span class="toc-text">1.简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B-1"><span class="toc-number">3.2.</span> <span class="toc-text">2.算法流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1%E5%88%9D%E5%A7%8B%E7%BD%AE%E6%8D%A2%E5%92%8C%E9%80%86%E5%88%9D%E5%A7%8B%E7%BD%AE%E6%8D%A2"><span class="toc-number">3.2.1.</span> <span class="toc-text">2.1初始置换和逆初始置换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2%E8%BD%AE%E5%87%BD%E6%95%B0"><span class="toc-number">3.2.2.</span> <span class="toc-text">2.2轮函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3%E5%AF%86%E9%92%A5%E7%BC%96%E6%8E%92"><span class="toc-number">3.2.3.</span> <span class="toc-text">2.3密钥编排</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0-1"><span class="toc-number">3.3.</span> <span class="toc-text">3.算法实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1%E5%88%9D%E5%A7%8B%E7%BD%AE%E6%8D%A2%E5%92%8C%E9%80%86%E5%88%9D%E5%A7%8B%E7%BD%AE%E6%8D%A2"><span class="toc-number">3.3.1.</span> <span class="toc-text">3.1初始置换和逆初始置换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-E%E7%9B%92%E6%89%A9%E5%B1%95"><span class="toc-number">3.3.2.</span> <span class="toc-text">3.2 E盒扩展</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E5%AF%86%E9%92%A5%E5%8A%A0"><span class="toc-number">3.3.3.</span> <span class="toc-text">3.3 密钥加</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-S%E7%9B%92%E4%BB%A3%E6%8D%A2"><span class="toc-number">3.3.4.</span> <span class="toc-text">3.4 S盒代换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-P%E7%9B%92%E7%BD%AE%E6%8D%A2"><span class="toc-number">3.3.5.</span> <span class="toc-text">3.5 P盒置换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6%E5%AD%90%E5%AF%86%E9%92%A5%E7%94%9F%E6%88%90"><span class="toc-number">3.3.6.</span> <span class="toc-text">3.6子密钥生成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7%E5%8D%95%E6%AC%A1%E5%8A%A0%E5%AF%86%E8%BF%87%E7%A8%8B"><span class="toc-number">3.3.7.</span> <span class="toc-text">3.7单次加密过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-8%E5%8D%95%E6%AC%A1%E8%A7%A3%E5%AF%86%E8%BF%87%E7%A8%8B"><span class="toc-number">3.3.8.</span> <span class="toc-text">3.8单次解密过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%AE%97%E6%B3%95%E9%AA%8C%E8%AF%81-1"><span class="toc-number">3.4.</span> <span class="toc-text">4.算法验证</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-number">3.5.</span> <span class="toc-text">5.算法分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1%E4%BA%92%E8%A1%A5%E6%80%A7"><span class="toc-number">3.5.1.</span> <span class="toc-text">5.1互补性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2%E5%BC%B1%E5%AF%86%E9%92%A5"><span class="toc-number">3.5.2.</span> <span class="toc-text">5.2弱密钥</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3%E8%BF%AD%E4%BB%A3%E8%BD%AE%E6%95%B0"><span class="toc-number">3.5.3.</span> <span class="toc-text">5.3迭代轮数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4%E5%AF%86%E9%92%A5%E9%95%BF%E5%BA%A6"><span class="toc-number">3.5.4.</span> <span class="toc-text">5.4密钥长度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E9%80%89%E6%8B%A9%E5%B7%A5%E5%85%B7%E5%8E%9F%E5%9B%A0"><span class="toc-number">3.6.</span> <span class="toc-text">6.选择工具原因</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E5%AE%9E%E7%8E%B0%E9%9A%BE%E7%82%B9"><span class="toc-number">3.7.</span> <span class="toc-text">7.实现难点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81-RSA%E7%AE%97%E6%B3%95"><span class="toc-number">4.</span> <span class="toc-text">四、非对称密码-RSA算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%AE%80%E4%BB%8B-3"><span class="toc-number">4.1.</span> <span class="toc-text">1.简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B-2"><span class="toc-number">4.2.</span> <span class="toc-text">2.算法流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1%E5%AF%86%E9%92%A5%E7%94%9F%E6%88%90"><span class="toc-number">4.2.1.</span> <span class="toc-text">2.1密钥生成</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0-2"><span class="toc-number">4.3.</span> <span class="toc-text">3.算法实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1%E7%94%9F%E6%88%90%E5%A4%A7%E5%A5%87%E6%95%B0"><span class="toc-number">4.3.1.</span> <span class="toc-text">3.1生成大奇数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2%E5%BF%AB%E9%80%9F%E5%B9%82"><span class="toc-number">4.3.2.</span> <span class="toc-text">3.2快速幂</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3%E7%B4%A0%E6%80%A7%E6%A3%80%E9%AA%8C"><span class="toc-number">4.3.3.</span> <span class="toc-text">3.3素性检验</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4%E4%BA%A7%E7%94%9F%E5%A4%A7%E7%B4%A0%E6%95%B0"><span class="toc-number">4.3.4.</span> <span class="toc-text">3.4产生大素数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5%E6%B1%82%E6%A8%A1%E9%80%86"><span class="toc-number">4.3.5.</span> <span class="toc-text">3.5求模逆</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%AE%97%E6%B3%95%E9%AA%8C%E8%AF%81-2"><span class="toc-number">4.4.</span> <span class="toc-text">4.算法验证</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90-1"><span class="toc-number">4.5.</span> <span class="toc-text">5.算法分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1%E5%9B%A0%E5%AD%90%E5%88%86%E8%A7%A3%E6%B3%95"><span class="toc-number">4.5.1.</span> <span class="toc-text">5.1因子分解法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2%E5%85%B1%E6%A8%A1%E6%94%BB%E5%87%BB"><span class="toc-number">4.5.2.</span> <span class="toc-text">5.2共模攻击</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3%E4%BD%8E%E5%8A%A0%E5%AF%86%E6%8C%87%E6%95%B0%E6%94%BB%E5%87%BB"><span class="toc-number">4.5.3.</span> <span class="toc-text">5.3低加密指数攻击</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4%E5%BE%AA%E7%8E%AF%E6%94%BB%E5%87%BB"><span class="toc-number">4.5.4.</span> <span class="toc-text">5.4循环攻击</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E9%80%89%E6%8B%A9%E5%B7%A5%E5%85%B7%E5%8E%9F%E5%9B%A0-1"><span class="toc-number">4.6.</span> <span class="toc-text">6.选择工具原因</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E5%AE%9E%E7%8E%B0%E9%9A%BE%E7%82%B9-1"><span class="toc-number">4.7.</span> <span class="toc-text">7.实现难点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81Hash%E5%87%BD%E6%95%B0-MD5%E7%AE%97%E6%B3%95"><span class="toc-number">5.</span> <span class="toc-text">五、Hash函数-MD5算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%AE%80%E4%BB%8B-4"><span class="toc-number">5.1.</span> <span class="toc-text">1.简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B-3"><span class="toc-number">5.2.</span> <span class="toc-text">2.算法流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1%E9%99%84%E5%8A%A0%E5%A1%AB%E5%85%85%E4%BD%8D"><span class="toc-number">5.2.1.</span> <span class="toc-text">2.1附加填充位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2%E5%88%9D%E5%A7%8B%E5%8C%96%E9%93%BE%E6%8E%A5%E5%8F%98%E9%87%8F"><span class="toc-number">5.2.2.</span> <span class="toc-text">2.2初始化链接变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3%E5%88%86%E7%BB%84%E5%A4%84%E7%90%86"><span class="toc-number">5.2.3.</span> <span class="toc-text">2.3分组处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4%E6%AD%A5%E5%87%BD%E6%95%B0"><span class="toc-number">5.2.4.</span> <span class="toc-text">2.4步函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0-3"><span class="toc-number">5.3.</span> <span class="toc-text">3.算法实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1%E9%99%84%E5%8A%A0%E5%A1%AB%E5%85%85%E4%BD%8D"><span class="toc-number">5.3.1.</span> <span class="toc-text">3.1附加填充位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2%E5%88%86%E7%BB%84%E5%A4%84%E7%90%86%E5%8F%8A%E6%AD%A5%E5%87%BD%E6%95%B0"><span class="toc-number">5.3.2.</span> <span class="toc-text">3.2分组处理及步函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-number">5.3.3.</span> <span class="toc-text">3.3输出结果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%AE%97%E6%B3%95%E9%AA%8C%E8%AF%81-3"><span class="toc-number">5.4.</span> <span class="toc-text">4.算法验证</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90-2"><span class="toc-number">5.5.</span> <span class="toc-text">5.算法分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E9%80%89%E6%8B%A9%E5%B7%A5%E5%85%B7%E5%8E%9F%E5%9B%A0-2"><span class="toc-number">5.6.</span> <span class="toc-text">6.选择工具原因</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E5%AE%9E%E7%8E%B0%E9%9A%BE%E7%82%B9-2"><span class="toc-number">5.7.</span> <span class="toc-text">7.实现难点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E7%BB%BC%E5%90%88%E5%AE%9E%E9%AA%8C"><span class="toc-number">6.</span> <span class="toc-text">六、综合实验</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%AE%80%E4%BB%8B-5"><span class="toc-number">6.1.</span> <span class="toc-text">1.简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B-4"><span class="toc-number">6.2.</span> <span class="toc-text">2.算法流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0-4"><span class="toc-number">6.3.</span> <span class="toc-text">3.算法实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81"><span class="toc-number">6.3.1.</span> <span class="toc-text">3.1身份认证</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2%E5%8A%A0%E5%AF%86%E6%96%87%E4%BB%B6%E5%92%8C%E5%AF%B9%E7%A7%B0%E5%AF%86%E9%92%A5"><span class="toc-number">6.3.2.</span> <span class="toc-text">3.2加密文件和对称密钥</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3%E8%A7%A3%E5%AF%86%E5%AF%B9%E7%A7%B0%E5%AF%86%E9%92%A5%E5%92%8C%E6%96%87%E4%BB%B6"><span class="toc-number">6.3.3.</span> <span class="toc-text">3.3解密对称密钥和文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%AE%97%E6%B3%95%E9%AA%8C%E8%AF%81-4"><span class="toc-number">6.4.</span> <span class="toc-text">4.算法验证</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81"><span class="toc-number">6.4.1.</span> <span class="toc-text">4.1身份认证</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2%E5%8A%A0%E5%AF%86%E6%96%87%E4%BB%B6%E5%92%8C%E5%AF%B9%E7%A7%B0%E5%AF%86%E9%92%A5"><span class="toc-number">6.4.2.</span> <span class="toc-text">4.2加密文件和对称密钥</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3%E8%A7%A3%E5%AF%86%E5%AF%B9%E7%A7%B0%E5%AF%86%E9%92%A5%E5%92%8C%E6%96%87%E4%BB%B6"><span class="toc-number">6.4.3.</span> <span class="toc-text">4.3解密对称密钥和文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90-3"><span class="toc-number">6.5.</span> <span class="toc-text">5.算法分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E9%80%89%E6%8B%A9%E5%B7%A5%E5%85%B7%E5%8E%9F%E5%9B%A0-3"><span class="toc-number">6.6.</span> <span class="toc-text">6.选择工具原因</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E5%AE%9E%E7%8E%B0%E9%9A%BE%E7%82%B9-3"><span class="toc-number">6.7.</span> <span class="toc-text">7.实现难点</span></a></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://crownz-sec.github.io/2020/01/15/crypto_report/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://crownz-sec.github.io/2020/01/15/crypto_report/&text=密码学课程设计报告"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://crownz-sec.github.io/2020/01/15/crypto_report/&title=密码学课程设计报告"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://crownz-sec.github.io/2020/01/15/crypto_report/&is_video=false&description=密码学课程设计报告"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=密码学课程设计报告&body=Check out this article: https://crownz-sec.github.io/2020/01/15/crypto_report/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://crownz-sec.github.io/2020/01/15/crypto_report/&title=密码学课程设计报告"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://crownz-sec.github.io/2020/01/15/crypto_report/&title=密码学课程设计报告"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://crownz-sec.github.io/2020/01/15/crypto_report/&title=密码学课程设计报告"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://crownz-sec.github.io/2020/01/15/crypto_report/&title=密码学课程设计报告"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://crownz-sec.github.io/2020/01/15/crypto_report/&name=密码学课程设计报告&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://crownz-sec.github.io/2020/01/15/crypto_report/&t=密码学课程设计报告"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2020-2024
    crownZ
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.2/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->
 
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script> 




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script> 
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->

    <script type="text/javascript">
        var disqus_shortname = 'crownZz';

        (function(){
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        }());
    </script>

<!-- utterances Comments -->

</body>
</html>
